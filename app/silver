#ifndef _silver_
#define _silver_

#include <silver-intern> 
#include <silver-public> // if we dont include this, then users cannot use the library! lol.. perhaps thats an odd wall of a feature for this boilerplate

#define import_t_schema(X,Y,...) \
    enum_value(X,Y, none) \
    enum_value(X,Y, source) \
    enum_value(X,Y, library) \
    enum_value(X,Y, project) \
    enum_value(X,Y, includes)
declare_enum(import_t)

#define build_state_schema(X,Y,...) \
    enum_value(X,Y, none) \
    enum_value(X,Y, built)
declare_enum(build_state)

#define completer_context_schema(X,Y,...) \
    i_prop(X,Y, required, model,    data) \
    i_prop(X,Y, required, array,    body)
declare_class(completer_context)

/// todo: make macro column out of i_ vs s_
/// its probably going to make a few more macros

#define silver_schema(X,Y,...)\
    i_prop    (X,Y, intern,     bool,           in_ref) \
    i_prop    (X,Y, intern,     bool,           in_top) \
    i_prop    (X,Y, intern,     bool,           in_const) \
    i_prop    (X,Y, intern,     bool,           in_left) \
    i_prop    (X,Y, intern,     bool,           in_inlay) \
    i_prop    (X,Y, intern,     bool,           prebuild) \
    i_prop    (X,Y, intern,     member,         in_assign) \
    i_prop    (X,Y, intern,     array,          imports) \
    i_prop    (X,Y, intern,     array,          main_symbols) \
    i_prop    (X,Y, intern,     array,          compiled_objects) \
    i_prop    (X,Y, intern,     array,          products_used) \
    i_prop    (X,Y, intern,     map,            include) \
    i_prop    (X,Y, intern,     int,            expr_level) \
    i_prop    (X,Y, intern,     string,         current_include) \
    i_prop    (X,Y, public,     path,           file) \
    i_prop    (X,Y, public,     array,          tokens) \
    i_prop    (X,Y, public,     num,            cursor) \
    i_prop    (X,Y, intern,     array,          stack) \
    i_method  (X,Y, public,     node,           parse_member_expr, member) \
    i_method  (X,Y, public,     none,           incremental_resolve) \
    i_method  (X,Y, public,     none,           push_state,   array, num) \
    i_method  (X,Y, public,     none,           push_current) \
    i_method  (X,Y, public,     none,           pop_state, bool) \
    i_method  (X,Y, public,     token,          next) \
    i_method  (X,Y, public,     token,          prev) \
    i_method  (X,Y, public,     token,          navigate, i32) \
    i_method  (X,Y, public,     token,          consume) \
    i_method  (X,Y, public,     token,          peek) \
    i_method  (X,Y, public,     token,          element, num) \
    i_method  (X,Y, public,     num,            line) \
    i_method  (X,Y, public,     bool,           next_is, symbol) \
    i_method  (X,Y, public,     array,          namespace_push) \
    i_method  (X,Y, public,     none,           namespace_pop, array) \
    i_method  (X,Y, public,     node,           read_node) \
    i_method  (X,Y, public,     node,           parse_ternary, node) \
    i_method  (X,Y, public,     node,           parse_assignment, member, string) \
    i_method  (X,Y, public,     bool,           read, symbol) \
    i_method  (X,Y, public,     object,         read_literal) \
    i_method  (X,Y, public,     string,         read_string) \
    i_method  (X,Y, public,     string,         read_alpha) \
    i_method  (X,Y, public,     string,         peek_keyword) \
    i_method  (X,Y, public,     string,         read_keyword) \
    i_method  (X,Y, public,     object,         read_bool) \
    i_method  (X,Y, public,     object,         read_numeric) \
    i_method  (X,Y, public,     string,         read_assign, ARef, ARef) \
    i_method  (X,Y, public,     string,         location) \
    i_method  (X,Y, public,     none,           parse) \
    i_method  (X,Y, public,     bool,           compile) \
    i_override(X,Y, method,     build_initializer) \
    i_override(X,Y, method,     init)
declare_mod(silver, ether, model)


/// import is a model now so it may parse as such
/// everything is very translatable to member: type  syntax
/// we may go type first and do simple behavior there depending
/// on context

#define import_schema(X,Y,...) \
    i_prop    (X,Y, intern, array,      source) \
    i_prop    (X,Y, intern, string,     shell) \
    i_prop    (X,Y, intern, path,       module_path) \
    i_prop    (X,Y, intern, bool,       imported) \
    i_prop    (X,Y, intern, array,      includes) \
    i_prop    (X,Y, intern, string,     namespace) \
    i_prop    (X,Y, intern, array,      links) \
    i_prop    (X,Y, intern, array,      cfiles) \
    i_prop    (X,Y, intern, array,      products) \
    i_prop    (X,Y, intern, array,      build_args) \
    i_prop    (X,Y, intern, import_t,   import_type) \
    i_prop    (X,Y, intern, array,      library_exports) \
    i_prop    (X,Y, intern, interface,  visibility) \
    i_prop    (X,Y, intern, string,     main_symbol) \
    i_prop    (X,Y, intern, bool,       assemble_so) \
    i_prop    (X,Y, intern, bool,       skip_process) \
    i_prop    (X,Y, intern, bool,       anonymous) \
    i_prop    (X,Y, intern, silver,     extern_mod) \
    i_method  (X,Y, public, none,       process) \
    i_override(X,Y, method, init)
declare_mod(import, model)

//#define set(I,...) ftableI(I) -> set(I, ##__VA_ARGS__)

#endif