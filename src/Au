#ifndef _Au_
#define _Au_

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#ifndef _WIN32
#include <libgen.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#endif
#include <math.h>
#include <setjmp.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950288
#endif

#define forward(t) typedef struct _##t* t;


#ifdef __cplusplus
extern "C" {
#endif

typedef struct _Au_t *Au_t;

struct _array;
struct _Au_t;

#define a(...) array_of(__VA_ARGS__ __VA_OPT__(,) null)
#define m(...)   map_of(__VA_ARGS__ __VA_OPT__(,) null)

#define len(I,...) ({ __typeof__(I) _i_ = I; _i_ ? (num)ftableI(_i_)->ft.len((collective)_i_, ## __VA_ARGS__) : (num)0; })


#undef bool
#undef false
#undef true

#define true                (bool)1
#define false               (bool)0
#define stringify(x)               stringify_actual(x)
#define stringify_actual(x)        #x
#ifdef __cplusplus
#define null                nullptr
#else
#define null                ((void*)0)
#endif
#define FNV_PRIME           0x100000001b3
#define OFFSET_BASIS        0xcbf29ce484222325

forward(string)

typedef struct __error_t {
    jmp_buf env;
    struct __error_t* prev;
    string message;
} __error_t;

extern __thread __error_t* Au_error_top;

#define attempt() \
    { \
        __error_t _frame; \
        _frame.prev = Au_error_top; \
        Au_error_top = &_frame; \
        if (setjmp(_frame.env) == 0)

#define on_error() \
    else

#define finally() \
        Au_error_top = _frame.prev; \
    }


void toss(string msg);

/// Au runtime
typedef void                    none;
typedef signed char             i8;
typedef short                   i16;
typedef int                     i32;
typedef long long               i64;
typedef unsigned char           u8;
typedef unsigned short          u16;
typedef unsigned int            u32;
typedef unsigned long long      u64;

typedef u64                     AF;
typedef long long               num;
typedef long long               sz;      /// a signed 64 bit size lets us act like python, so this is a type for the purpose of indexing and all valid sizes
#ifndef __cplusplus
typedef u8                      bool;
#endif
typedef float                   f32;
typedef double                  f64;
typedef double                  real;    /// real enough
typedef void*                   handle;
typedef char*                   cstr;
typedef const char*             symbol;
typedef bool                   *ref_bool;

typedef __fp16                  fp16;
typedef __bf16                  bf16;


typedef struct cereal { char* value; } cereal;

// typedef struct _object*         Au;
typedef struct _Au**             ARef; /// registered for a generic raw, but we must transition to use 'raw' in cases where they are not Au-allocations
typedef float*                  floats;
typedef cstr*                   cstrs;
typedef void*                   raw;        // abstract types are void*
typedef void*                   numeric;


#include <object.h>

#undef assert
#include <macros.h>


typedef signed char            *ref_i8;
typedef short                  *ref_i16;
typedef int                    *ref_i32;
typedef long long              *ref_i64;
typedef unsigned char          *ref_u8;
typedef unsigned short         *ref_u16;
typedef unsigned int           *ref_u32;
typedef unsigned long long     *ref_u64;
typedef float                  *ref_f32;
typedef double                 *ref_f64;

#define Au_f_members(B) \
    Au_t            context; \
    union { Au_t src, rtype; }; \
    Au_t            schema; \
    Au_t            user; \
    Au_t            module; \
    Au_t            ptr; \
    char*           ident; \
    char*           alt; \
    u32             abi_size; \
    u8              align_bits; \
    ARef            llscope; \
    ARef            lltype; \
    ARef            lldebug; \
    i64             index; \
    object          value; \
    u8              member_type; \
    u8              operator_type; \
    u8              access_type; \
    u8              reserved; \
    u32             traits; \
    int             global_count; \
    int             offset; \
    int             size; \
    int             isize; \
    void*           fn; \
    ffi_method_t*   ffi; \
    au_core         af; \
    struct _object  members_info; \
    struct _collective_abi  members; \
    struct _object  meta_info; \
    struct _collective_abi  meta; \
    struct _shape*  shape; \
    u64             required_bits[2];

typedef struct _au_core {
    struct _object** af4;
    i64     af_count;
    i64     af_alloc;
    struct _object** re;
    i64     re_count;
    i64     re_alloc;
    void*   arb;
} *au_core;

#define declare_typedef(X) \
    typedef struct _ ## X* X;

#define decl_type(AA) \
    typedef struct _##AA##_info { \
        struct _Au     info; \
        AA##_f        type; \
    } AA##_info; \
    extern AA##_info   AA##_i; \

#define declare_base( AA ) \
    declare_typedef(AA) \
    _Pragma("pack(push, 1)") \
    struct AA ## _fields { \
        u8 __none__; \
    }; \
    typedef struct _ ## AA { \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL) \
    typedef struct _##AA##_f { \
        Au_f_members(Au) \
        struct { void(*_ff)(); \
            AA##_schema (AA, METHOD) \
        } ft; \
    } AA##_f; \
    typedef struct _##AA##_t_info { \
        struct _Au     info; \
        struct _##AA##_t_ { \
            Au_f_members(Au) \
        } type; \
    } AA##_t_info; \
    extern AA##_t_info   AA##_t_i; \
    decl_type(AA) \
    _Pragma("pack(pop)")

// a void* is abstract enough
#define declare_abstract( X, ... ) \
    _Pragma("pack(push, 1)") \
    typedef void* X; \
    typedef struct _##X##_f { \
        Au_f_members(Au) \
        struct { void(*_ff)(); \
            Au_schema(Au, METHOD) \
            X##_schema(X, METHOD, __VA_ARGS__) \
        } ft; \
    } X##_f, *X##_ft; \
    decl_type(X) \
    _Pragma("pack(pop)") \


#define declare_primitive( AA, Y, ... ) \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA##_f { \
        Au_f_members(Au) \
        struct { void(*_ff)(); \
            Au_schema(Au, METHOD, __VA_ARGS__) \
            AA##_schema(AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define ENUM_COUNT(...)  (sizeof((int[]){__VA_ARGS__}) / sizeof(int))

// can technically use enums to phone home with real numbers
#define declare_typed_enum( E, T ) \
    typedef T E; \
    E##_schema(E, T, DECL) \
    _Pragma("pack(push, 1)") \
    typedef struct _##E##_f { \
        Au_f_members(Au) \
        struct { \
            Au_schema   (Au, METHOD) \
            E##_schema (Au, T, METHOD) \
        } ft; \
    } E##_f, *E##_ft; \
    static const i32 E##_ENUM_COUNT = ENUM_COUNT(E##_schema(E, T, COUNT)); \
    decl_type(E)\
    _Pragma("pack(pop)") \

#define declare_enum( E ) declare_typed_enum(E, i32)

void lazy_init(global_init_fn fn, Au_t);

#define define_typed_enum( E, T ) \
    E##_info E##_i;\
    static __attribute__((constructor)) bool global_##E() { \
        E ## _i.info.type = (Au_t)&E ## _i.type; \
        E ## _i.info.refs = 1000; \
        E ## _f* type_ref = &E ## _i.type; \
        Au_t base_ref     = &Au_i.type; \
        if ((Au_t)type_ref != (Au_t)base_ref && base_ref->size == 0) { \
            lazy_init((global_init_fn)&global_##E, (Au_t)base_ref); \
            return false; \
        } else { \
            memset(type_ref, 0, sizeof(E##_i.type)); \
            memcpy(&type_ref->ft, &base_ref->ft, sizeof(__typeof__(base_ref->ft))); \
            type_ref->members.alloc     = 16; \
            type_ref->members.assorted  = true; \
            type_ref->members.unmanaged = true; \
            vector_init(&type_ref->members); \
            type_ref->meta.alloc        = 16; \
            type_ref->meta.assorted  = true; \
            type_ref->meta.unmanaged = true; \
            array_init(&type_ref->meta); \
            type_ref->src      = typeid(T); \
            type_ref->context   = (__typeof__(E##_i.type.context))& Au_i.type; \
            type_ref->ident    = #E;                 \
            type_ref->module   = Au_module(MODULE); \
            type_ref->size     = sizeof(E);          \
            type_ref->traits   = AU_TRAIT_ENUM;       \
            E##_schema( E, T, IMPL ); \
            push_type((Au_t)type_ref); \
            return true; \
        } \
    }


#define define_enum( E ) \
    define_typed_enum(E, i32)

#define FIELD_ID(TYPE, MEMBER) offsetof(struct TYPE##_fields, MEMBER)

#define declare_class\
(AA, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        AA##_intern (AA, F, __VA_ARGS__) \
    }; \
    typedef struct _##AA { \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        u8 AA##_interns [0 AA##_intern(AA, ISIZE, __VA_ARGS__)]; \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            Au_schema(AA, METHOD, __VA_ARGS__) \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")


#define declare_class_2\
(AA, BB, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
    }; \
    typedef struct _##AA { \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        u8 BB##_interns [0 BB##_intern (BB, ISIZE, __VA_ARGS__)]; \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        u8 AA##_interns [0 AA##_intern (AA, ISIZE, __VA_ARGS__)]; \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            Au_schema(AA, METHOD, __VA_ARGS__) \
            BB##_schema (BB, METHOD, __VA_ARGS__) \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define declare_class_3\
(AA, BB, CC, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        CC##_intern (CC, F, __VA_ARGS__) \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
    }; \
    typedef struct _##AA { \
        CC##_intern (CC, INST_U, __VA_ARGS__) \
        CC##_intern (CC, INST_L, __VA_ARGS__) \
        u8 CC##_interns [0 CC##_intern (CC, ISIZE, __VA_ARGS__)]; \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        u8 BB##_interns [0 BB##_intern (BB, ISIZE, __VA_ARGS__)]; \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        u8 AA##_interns [0 AA##_intern (AA, ISIZE, __VA_ARGS__)]; \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            Au_schema(AA, METHOD, __VA_ARGS__) \
            CC##_schema (CC, METHOD, __VA_ARGS__) \
            BB##_schema (BB, METHOD, __VA_ARGS__) \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

// emit A-type compatible structs
// we may ALSO emit Au macros as well, however its slightly hacky in nature
// because we need t
#define declare_class_4\
(AA, BB, CC, DD, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        DD##_intern (DD, F, __VA_ARGS__) \
        CC##_intern (CC, F, __VA_ARGS__) \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
    }; \
    typedef struct _##AA { \
        DD##_intern (DD, INST_U, __VA_ARGS__) \
        DD##_intern (DD, INST_L, __VA_ARGS__) \
        u8 DD##_interns [0 DD##_intern (DD, ISIZE, __VA_ARGS__)]; \
        CC##_intern (CC, INST_U, __VA_ARGS__) \
        CC##_intern (CC, INST_L, __VA_ARGS__) \
        u8 CC##_interns [0 CC##_intern (CC, ISIZE, __VA_ARGS__)]; \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        u8 BB##_interns [0 BB##_intern (BB, ISIZE, __VA_ARGS__)]; \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        u8 AA##_interns [0 AA##_intern (AA, ISIZE, __VA_ARGS__)]; \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            Au_schema(AA, METHOD, __VA_ARGS__) \
            DD##_schema (DD, METHOD, __VA_ARGS__) \
            CC##_schema (CC, METHOD, __VA_ARGS__) \
            BB##_schema (BB, METHOD, __VA_ARGS__) \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define arg_count_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define arg_count(...) arg_count_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define declare_base_meta\
(AA, BASE, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        BASE##_intern (AA, INST, __VA_ARGS__) \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    typedef struct _##AA##_f { \
        Au_f_members(BASE) \
        struct { void(*_ff)(); \
            BASE##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define declare_struct\
(AA,...) \
    typedef struct _##AA AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        AA##_schema (AA, INST, __VA_ARGS__) \
    } AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define initializer(fn) \
    static bool _initializer() { \
        fn(); \
        return true; \
    } \
    static __attribute__((constructor)) void _module_register() { \
        Au_register_init((global_init_fn)&_initializer); \
    }


void* primitive_ffi_arb(Au_t);

typedef Au_t* Au_ts;

#ifndef NDEBUG
#define IS_DEBUG 0
#else
#define IS_DEBUG 1
#endif

#define define_arb(TYPE, BASE, TYPE_SZ, TRAIT, ...) \
    _Pragma("pack(push, 1)") \
    __thread struct _au_core TYPE##_af; \
    TYPE##_info TYPE##_i; \
    _Pragma("pack(pop)") \
    static __attribute__((constructor)) bool Aglobal_##TYPE() { \
        TYPE##_f* type_ref = &TYPE##_i.type; \
        BASE##_f* base_ref = &BASE##_i.type; \
        if (!Au_t_i.type.ident) { \
            Au_t_i.type.ident   = "Au_t"; \
            Au_t_i.type.src    = typeid(Au); \
            push_type((Au_t)&Au_t_i.type); \
        } \
        if ((Au_t)type_ref != (Au_t)base_ref && (!base_ref->traits)) { \
            lazy_init((global_init_fn)&Aglobal_##TYPE, (Au_t)base_ref); \
            return false; \
        } else { \
            memset(type_ref, 0, sizeof(TYPE##_i.type)); \
            if ((Au_t)type_ref != (Au_t)base_ref) \
                memcpy(&type_ref->ft, &base_ref->ft, sizeof(BASE##_i.type.ft)); \
            type_ref->member_type       = AU_MEMBER_TYPE; \
            type_ref->members.alloc     = 128; \
            type_ref->members.assorted  = true; \
            type_ref->members.unmanaged = true; \
            array_init(&type_ref->members); \
            type_ref->meta.alloc        = 16; \
            type_ref->meta.assorted     = true; \
            type_ref->meta.unmanaged    = true; \
            array_init(&type_ref->meta); \
            type_ref->ident             = #TYPE; \
            type_ref->af                = &TYPE##_af; \
            type_ref->isize             = 0 TYPE##_schema( TYPE, ISIZE_EXTERN, __VA_ARGS__ ); \
            type_ref->context            = (__typeof__(type_ref->context))&BASE##_i.type; \
            type_ref->module            = Au_module((cstr)MODULE); \
            type_ref->size              = TYPE_SZ; \
            type_ref->traits            = TRAIT; \
            set_meta_array(type_ref, emit_types(__VA_ARGS__)); \
            TYPE##_schema( TYPE, INIT, __VA_ARGS__ ); \
            push_type((Au_t)type_ref); \
            return true; \
        } \
    } \


#define define_any(A0, A1, SZ, traits, ...) \
    define_arb(A0, A1, SZ, traits, __VA_ARGS__)

#define define_class(A0, A1, ...) \
    define_any(A0, A1, sizeof(struct _##A0), AU_TRAIT_CLASS, __VA_ARGS__)

#define define_struct(A0, ...) \
    define_any(A0, A0, sizeof(struct _##A0), AU_TRAIT_STRUCT, __VA_ARGS__)

#define define_primitive(A0, A1, traits, ...) \
    define_any(A0, A1, sizeof(A0), traits | AU_TRAIT_PRIMITIVE, __VA_ARGS__)

#define define_abstract(A0, traits, ...) \
    define_any(A0, Au, 0, traits | AU_TRAIT_ABSTRACT, __VA_ARGS__)

struct _sz { i64 value; };


// true utility / internal functions
num clamp(num i, num mn, num mx);
real clampf(real, real, real);
i64 epoch_millis();
Au Au_initialize(Au);
none Au_init_recur(Au a, Au_t current, raw last_init);

/// Au properties are not user-accessible, 
/// so they are declared as opaque
/// the methods Are, accessible

forward(ctx)
forward(array)
forward(map)
forward(string)
forward(path)
forward(vector)
forward(any)


// Au must generate defines for sizes for users of it
#define Au_schema(AA,Y,...) \
    i_prop  (AA,Y, intern, Au_t,        type) \
    i_prop  (AA,Y, intern, Au_t,        scalar) \
    i_prop  (AA,Y, intern, i64,         refs) \
    i_prop  (AA,Y, intern, Au,          data) \
    i_prop  (AA,Y, intern, shape,       shape) \
    i_prop  (AA,Y, intern, cstr,        source) \
    i_prop  (AA,Y, intern, i64,         line) \
    i_prop  (AA,Y, intern, i64,         alloc) \
    i_prop  (AA,Y, intern, i64,         count) \
    i_prop  (AA,Y, intern, i64,         recycle) \
    i_prop  (AA,Y, intern, i64,         af_index) \
    i_array (AA,Y, intern, Au,       8,  meta) \
    i_method(AA,Y, public, none,        init) \
    i_method(AA,Y, public, none,        dealloc) \
    i_method(AA,Y, public, i32,         compare,             AA) \
    i_method(AA,Y, public, u64,         hash) \
    i_method(AA,Y, public, AA,          copy) \
    i_final (AA,Y, public, callback,    binding,             Au, bool, Au_t, Au_t, symbol, symbol) \
    i_final (AA,Y, public, ref_u64,     AF_bits) \
    i_final (AA,Y, public, none,        AF_set_id,           i32) \
    i_final (AA,Y, public, none,        AF_set_name,         cstr) \
    i_final (AA,Y, public, i32,         AF_query_name,       cstr) \
    i_final (AA,Y, public, Au,           instanceof,          Au_t) \
    i_final (AA,Y, public, AA,          hold) \
    i_final (AA,Y, public, none,        drop) \
    i_final (AA,Y, public, none,        hold_members) \
    i_final (AA,Y, public, none,        drop_members) \
    i_final (AA,Y, public, Au,           set_property,        symbol, Au) \
    i_final (AA,Y, public, Au,           get_property,        symbol) \
    i_final (AA,Y, public, Au,           vrealloc,            sz) \
    s_method(AA,Y, public, Au_t,         find_member,         Au_t, symbol, i32) \
    s_method(AA,Y, public, Au_t,         context,             array, i32, i32) \
    s_method(AA,Y, public, Au_t,         lexical,             array, symbol) \
    s_method(AA,Y, public, Au_t,         register,            Au_t, symbol, u32, u32) \
    s_method(AA,Y, public, Au_t,         register_type,       Au_t, symbol, u32) \
    s_method(AA,Y, public, Au_t,         register_member,     Au_t, symbol, Au_t, u32, u32) \
    s_method(AA,Y, public, Au_t,         register_class,      Au_t, symbol) \
    s_method(AA,Y, public, Au_t,         register_struct,     Au_t, symbol) \
    s_method(AA,Y, public, Au_t,         register_func_ptr,   Au_t, symbol) \
    s_method(AA,Y, public, Au_t,         register_pointer,    Au_t, Au_t, symbol) \
    s_method(AA,Y, public, Au_t,         register_enum,       Au_t, symbol, u32) \
    s_method(AA,Y, public, Au_t,         register_enum_value, Au_t, symbol, Au) \
    s_method(AA,Y, public, Au,           initialize,          Au) \
    s_method(AA,Y, public, Au_t,         module,              symbol) \
    s_method(AA,Y, public, Au_t,         register_module,     symbol) \
    s_method(AA,Y, public, Au_t,         global) \
    s_method(AA,Y, public, Au_t,         scope_lookup,        array, string) \
    s_method(AA,Y, public, Au_t,         current_module) \
    i_final (AA,Y, public, Au,           member_object,       Au_t) \
    i_final (AA,Y, public, bool,        member_set,           Au_t, Au) \
    i_final (AA,Y, public, Au,           header) \
    i_final (AA,Y, public, Au,           vdata) \
    i_final (AA,Y, public, Au_t,       vdata_type) \
    i_final (AA,Y, public, i64,         vdata_stride) \
    i_final (AA,Y, public, bool,        is_meta) \
    i_final (AA,Y, public, bool,        is_meta_compatible,  Au) \
    t_vargs (AA,Y, public, Au,           formatter,           handle, Au, symbol) \
    t_method(AA,Y, public, Au,           alloc,               num, Au_ts) \
    t_method(AA,Y, public, Au,           alloc_new,           num, Au_ts) \
    t_method(AA,Y, public, Au,           alloc_dbg,           num,     cstr,      i32) \
    t_method(AA,Y, public, Au,           alloc2,              Au_t,   shape) \
    t_method(AA,Y, public, string,      estring,             i32) \
    t_method(AA,Y, public, i32,         evalue,              cstr) \
    t_method(AA,Y, public, none,        serialize,           string,  Au) \
    t_method(AA,Y, public, Au,           convert,             Au) \
    t_method(AA,Y, public, bool,        inherits,            Au_t) \
    t_method(AA,Y, public, Au,           construct_with,      Au,         ctx) \
    t_method(AA,Y, public, bool,        constructs_with,     Au_t) \
    t_method(AA,Y, public, Au_t,        find_ctr,            Au_t, bool) \
    t_method(AA,Y, public, Au_t,        find_member,         AFlag, symbol,    bool) \
    t_method(AA,Y, public, Au_t,        member_first,        Au_t, bool) \
    t_method(AA,Y, public, Au_t,        member_type,         AFlag, Au_t,     bool) \
    t_method(AA,Y, public, Au,          primitive,           raw) \
    t_method(AA,Y, public, Au,          method,              cstr,    array) \
    t_method(AA,Y, public, Au,          parse,               cstr, ctx) \
    t_method(AA,Y, public, i32,         alloc_count) \
    t_method(AA,Y, public, none,        push_type) \
    s_method(AA,Y, public, none,        dealloc_type,        Au_t) \
    t_method(AA,Y, public, Au,          typecast,            Au) \
    s_method(AA,Y, public, none,        member_override,     Au_t, Au_t, AFlag) \
    s_method(AA,Y, public, none,        register_init,       func) \
    s_method(AA,Y, public, bool,        is_inlay,            Au_t) \
    s_method(AA,Y, public, Au_t,        find_type,           symbol, Au_t) \
    s_method(AA,Y, public, map,         arguments,           i32, cstrs, map, Au) \
    s_method(AA,Y, public, ARef,        types,               ref_i64) \
    s_method(AA,Y, public, none,        tap,                 symbol, hook) \
    s_method(AA,Y, public, none,        untap,               symbol) \
    s_method(AA,Y, public, none,        recycle) \
    s_method(AA,Y, public, none,        engage,              cstrs) \
    s_vargs (AA,Y, public, map,         args,                cstrs, symbol) \
    s_vargs (AA,Y, public, map,         map_of,              symbol) \
    i_final (AA,Y, public, bool,        is_generic) \
    i_final (AA,Y, public, bool,        is_integral) \
    i_final (AA,Y, public, bool,        is_void) \
    i_final (AA,Y, public, bool,        is_double) \
    i_final (AA,Y, public, bool,        is_float) \
    i_final (AA,Y, public, bool,        is_realistic) \
    i_final (AA,Y, public, bool,        is_bool) \
    i_final (AA,Y, public, bool,        is_class) \
    i_final (AA,Y, public, bool,        is_struct) \
    i_final (AA,Y, public, bool,        is_func) \
    i_final (AA,Y, public, bool,        is_imethod) \
    i_final (AA,Y, public, Au_t,        is_rec) \
    i_final (AA,Y, public, bool,        is_prim) \
    i_final (AA,Y, public, bool,        is_sign) \
    i_final (AA,Y, public, bool,        is_unsign) \
    i_final (AA,Y, public, bool,        is_ptr) \
    i_final (AA,Y, public, bool,        is_enum) \
    i_final (AA,Y, public, bool,        is_type) \
    i_ctr   (AA,Y, public, cereal) \
    i_ctr(AA,Y, public, cstrs) \
    i_cast  (AA,Y, public, string) \
    i_cast  (AA,Y, public, Au_t) \
    i_cast  (AA,Y, public, bool)

#define Au_intern_footer(AA)

#define Au_intern(AA,YY,...) Au_schema(AA,YY,__VA_ARGS__)

//typedef struct _shape *shape;
forward(shape)
declare_base(Au)


#define typeid(AA)   ((Au_t)&AA##_i.type)
#define scalarof(AA) head(AA)->scalar

forward(item)

// these methods could-be var-arg, however not recommended?
#define collective_schema(AA,Y,...) \
    i_prop           (AA,Y, public, i32,     count) \
    i_prop           (AA,Y, public, i32,     alloc) \
    i_prop           (AA,Y, public, i32,     hsize) \
    i_vprop          (AA,Y, public, Au,      origin) \
    i_prop           (AA,Y, public, item,    first) \
    i_prop           (AA,Y, public, item,    last) \
    i_prop           (AA,Y, public, vector,  hlist) \
    i_prop           (AA,Y, public, bool,    unmanaged)  \
    i_prop           (AA,Y, public, bool,    assorted) \
    i_prop           (AA,Y, public, Au_t,    last_type) \
    i_prop(AA,Y, public, Au_t,   type) \
    i_prop(AA,Y, public, shape,   shape) \
    i_override(AA,Y, method, init) \
    i_guard          (AA,Y, public, num,     len) \
    i_method         (AA,Y, public, Au,      peek, num)
declare_class(collective)


#define numeric_schema(AA,Y,...) \
    i_operator(AA,Y, public, numeric, _add, numeric) \
    i_operator(AA,Y, public, numeric, _sub, numeric) \
    i_operator(AA,Y, public, numeric, _mul, numeric) \
    i_operator(AA,Y, public, numeric, _div, numeric) \
    i_operator(AA,Y, public, numeric, _or, numeric) \
    i_operator(AA,Y, public, numeric, _and, numeric) \
    i_operator(AA,Y, public, numeric, _xor, numeric) \
    i_operator(AA,Y, public, numeric, _mod, numeric) \
    i_operator(AA,Y, public, numeric, _right, numeric) \
    i_operator(AA,Y, public, numeric, _left,  numeric) \
    i_operator(AA,Y, public, numeric, _compare,   numeric) \
    i_operator(AA,Y, public, numeric, _equal,     numeric) \
    i_operator(AA,Y, public, numeric, _not_equal, numeric) \
    i_operator(AA,Y, public, none,    _assign,    numeric) \
    i_override(AA,Y, cast, string)
declare_abstract(numeric)


#define string_like_schema(X,Y,...)
declare_abstract(string_like)

#define nil_schema(X,Y,...)
declare_abstract(nil)

#define raw_schema(X,Y,...)
declare_abstract(raw)
 
#define ref_schema(X,Y,...)
declare_abstract(ref)

#define imported_schema(X,Y,...)
declare_abstract(imported)

#define ARef_schema(X,Y,...)        ref_schema(X,Y,...)
#define i8_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define i16_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define i32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define i64_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u8_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define u16_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u64_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define fp16_schema(X,Y,...)        numeric_schema(numeric,Y,...)
#define bf16_schema(X,Y,...)        numeric_schema(numeric,Y,...)
#define f32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define f64_schema(X,Y,...)         numeric_schema(numeric,Y,...)

#define fmt(...) ((string)f(string, __VA_ARGS__))

#define ref_i8_schema(X,Y,...)      numeric_schema(numeric,Y,...)
#define ref_i16_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_i32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_i64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u8_schema(X,Y,...)      numeric_schema(numeric,Y,...)
#define ref_u16_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_f32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_f64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_bool_schema(X,Y,...)    numeric_schema(numeric,Y,...)

#define AFlag_schema(X,Y,...)       numeric_schema(numeric,Y,...)
#define bool_schema(X,Y,...)        numeric_schema(numeric,Y,...)
#define num_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define sz_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define cstr_schema(X,Y,...)        string_like_schema(X,Y,...)
#define symbol_schema(X,Y,...)      string_like_schema(X,Y,...)
#define cereal_schema(X,Y,...)      raw_schema(X,Y,...)
#define none_schema(X,Y,...)        nil_schema(X,Y,...)
#define raw_t_schema(X,Y,...)       raw_schema(X,Y,...)
#define handle_schema(X,Y,...)      raw_schema(X,Y,...)
#define Au_t_schema(X,Y,...)       raw_schema(X,Y,...)
#define func_schema(X,Y,...)        raw_schema(X,Y,...)
#define hook_schema(X,Y,...)        raw_schema(X,Y,...)
#define callback_schema(X,Y,...)    raw_schema(X,Y,...)
#define callback_extra_schema(X,Y,...)    raw_schema(X,Y,...)
#define cstrs_schema(X,Y,...)       raw_schema(X,Y,...)
#define Au_ts_schema(X,Y,...)      raw_schema(X,Y,...)
#define floats_schema(X,Y,...)      raw_schema(X,Y,...)


/// meta gives us access to one token we can override with (F)

static inline bool AF_get(u64* f, u32 bit_index) {
    if (bit_index < 64) {
        return (f[0] & (((u64)1) << bit_index)) != 0;
    } else {
        return (f[1] & (((u64)1) << (bit_index - 64))) != 0;
    }
}

#define AF_set(f, bit_index) ({ \
    if (bit_index < 64) { \
        ((u64*)f)[0] |= ((u64)1) << bit_index; \
    } else { \
        ((u64*)f)[1] |= ((u64)1) << (bit_index - 64); \
    } \
})

/*
static inline void AF_set(u64* f, u32 bit_index) {
    if (bit_index < 64) {
        f[0] |= ((u64)1) << bit_index;
    } else {
        f[1] |= ((u64)1) << (bit_index - 64);
    }
}
*/

declare_primitive(ref_i8,           numeric)
declare_primitive(ref_i16,          numeric)
declare_primitive(ref_i32,          numeric)
declare_primitive(ref_i64,          numeric)
declare_primitive(ref_u8,           numeric)
declare_primitive(ref_u16,          numeric)
declare_primitive(ref_u32,          numeric)
declare_primitive(ref_u64,          numeric)
declare_primitive(ref_f32,          numeric)
declare_primitive(ref_f64,          numeric)
declare_primitive(ref_bool,         numeric)

declare_primitive( i8,              numeric)
declare_primitive(i16,              numeric)
declare_primitive(i32,              numeric)
declare_primitive(i64,              numeric)
declare_primitive( u8,              numeric)
declare_primitive(u16,              numeric)
declare_primitive(u32,              numeric)
declare_primitive(u64,              numeric)
declare_primitive(fp16,             numeric)
declare_primitive(bf16,             numeric)
declare_primitive(f32,              numeric)
declare_primitive(f64,              numeric)
declare_primitive(AFlag,            numeric)
declare_primitive(bool,             numeric)
declare_primitive(num,              numeric)
declare_primitive(sz,               numeric)
declare_primitive(cstr,             string_like)
declare_primitive(symbol,           string_like)
declare_primitive(none,             nil)
declare_primitive(cereal,           raw)
declare_primitive(raw_t,            raw)
declare_primitive(handle,           raw)
declare_primitive(func,             raw)
declare_primitive(hook,             raw)
declare_primitive(callback,         raw)
declare_primitive(callback_extra,   raw)
declare_primitive(cstrs,            raw)
declare_primitive(Au_ts,           raw)

/// whatever we can 'name', we can handle as a type of any pointer primitive
//declare_primitive(Au_t,        raw)
declare_primitive(ARef,         ref)
declare_primitive(floats,       raw)




/// lets mimmick the structure in llama.cpp
#define msg_schema(X,Y,...) \
    i_prop(X,Y, public,   cstr, role) \
    i_prop(X,Y, public,   cstr, content) \
    i_override(X,Y, method, init) \
    i_override(X,Y, method, dealloc)
declare_class(msg)

#undef shape

forward(shape)

#ifndef __cplusplus
#define shape_schema(AA,YY,...) \
    i_prop  (AA,YY, public, i64, count) \
    i_vprop (AA,YY, public, i64, data) \
    i_prop  (AA,YY, public, bool, is_global) \
    i_method(AA,YY, public, shape, with_array, array) \
    i_method(AA,YY, public, i64,   total) \
    i_method(AA,YY, public, none,  push, i64) \
    s_method(AA,YY, public, shape, from, i64, ref_i64) \
    s_method(AA,YY, public, shape, read, ARef) \
    s_vargs (AA,YY, public, shape, new_shape,  i64) \
    i_override(AA,YY, method, compare) \
    i_override(AA,YY, method, init) \
    i_override(AA,YY, method, dealloc)
declare_class(shape)
#else
// shape mysteriously defined in cpp somewhere else
ARef new_shape(i64, ...);
#endif


/// doubly-linked item type, integrated key so we dont also need a 'field' type
#define item_schema(X,Y,...) \
    i_prop    (X,Y, opaque, X,         next) \
    i_prop    (X,Y, opaque, X,         prev) \
    i_prop    (X,Y, opaque, Au,    ref) \
    i_prop    (X,Y, opaque, Au,    value) \
    i_prop    (X,Y, opaque, Au,    key) \
    i_prop    (X,Y, opaque, u64,       h) \
    i_override(X,Y, method, hash) \
    i_override(X,Y, method, init)
declare_class(item)

/// linked-list of elemental data
#define list_schema(X,Y,...) \
    i_method(X,Y, public,    Au,      pop) \
    i_method(X,Y, public,    item,    push, Au) \
    i_method(X,Y, public,    none,    push_item, item) \
    i_method(X,Y, public,    item,    insert_after, Au, i32) \
    i_method(X,Y, public,    num,     index_of, Au) \
    i_method(X,Y, public,    item,    item_of, Au) \
    i_method(X,Y, public,    none,    sort,   ARef) \
    i_method(X,Y, public,    none,    remove, num) \
    i_method(X,Y, public,    none,    remove_item, item) \
    i_method(X,Y, public,    Au,  get,  Au) \
    i_method(X,Y, public,    num,     count) \
    i_override(X,Y, method, dealloc)
declare_class_2(list, collective)

/// array of elemental data
/// important to define the same operators here in silver definition of runtime
/// one has arguments (operator) and (cast) does not, thats always instance
/// we need different names for these.  they cannot both be considered 'operators'
/// we also need new data structure, so ops vs casts vs constructs vs methods
// += -= *= /= 
// ":", "+=", "-=", "*=", "/=", "|=",
// "&=", "^=", ">>=", "<<=", "%=", null);
/*

static struct op_entry op_table[] = {
    { LLVMBuildAdd },
    { LLVMBuildSub }, 
    { LLVMBuildMul }, 
    { LLVMBuildSDiv }, 
    { LLVMBuildOr }, 
    { LLVMBuildAnd },
    { LLVMBuildOr }, 
    { LLVMBuildAnd },
    { LLVMBuildXor },  
    { LLVMBuildURem },
    { LLVMBuildAShr },
    { LLVMBuildShl }
};
*/

#define OPType_schema(E,T,Y,...) \
    enum_value(E,T,Y, _undefined,         0) \
    enum_value(E,T,Y, _add,               1) \
    enum_value(E,T,Y, _sub,               2) \
    enum_value(E,T,Y, _mul,               3) \
    enum_value(E,T,Y, _div,               4) \
    enum_value(E,T,Y, _or,                5) \
    enum_value(E,T,Y, _and,               6) \
    enum_value(E,T,Y, _bitwise_or,        7) \
    enum_value(E,T,Y, _bitwise_and,       8) \
    enum_value(E,T,Y, _xor,               9) \
    enum_value(E,T,Y, _mod,               10) \
    enum_value(E,T,Y, _right,             11) \
    enum_value(E,T,Y, _left,              12) \
    enum_value(E,T,Y, _compare,           13) \
    enum_value(E,T,Y, _equal,             14) \
    enum_value(E,T,Y, _not_equal,         15) \
    enum_value(E,T,Y, _greater,           16) \
    enum_value(E,T,Y, _less,              17) \
    enum_value(E,T,Y, _greater_eq,        18) \
    enum_value(E,T,Y, _less_eq,           19) \
    enum_value(E,T,Y, _is,                20) \
    enum_value(E,T,Y, _inherits,          21) \
    enum_value(E,T,Y, _value_default,     22) \
    enum_value(E,T,Y, _cond_value,        23) \
    enum_value(E,T,Y, _assign,            24) \
    enum_value(E,T,Y, _assign_add,        25) \
    enum_value(E,T,Y, _assign_sub,        26) \
    enum_value(E,T,Y, _assign_mul,        27) \
    enum_value(E,T,Y, _assign_div,        28) \
    enum_value(E,T,Y, _assign_or,         29) \
    enum_value(E,T,Y, _assign_and,        30) \
    enum_value(E,T,Y, _assign_xor,        31) \
    enum_value(E,T,Y, _assign_mod,        32) \
    enum_value(E,T,Y, _assign_right,      33) \
    enum_value(E,T,Y, _assign_left,       34)
declare_enum(OPType)



#define Key_schema(EE,TT,YY) \
    enum_value_v(EE, TT, YY, Undefined,      0) \
    enum_value_v(EE, TT, YY, Space,         32) \
    enum_value_v(EE, TT, YY, Apostrophe,    39) \
    enum_value_v(EE, TT, YY, Comma,         44) \
    enum_value_v(EE, TT, YY, Minus,         45) \
    enum_value_v(EE, TT, YY, Period,        46) \
    enum_value_v(EE, TT, YY, Slash,         47) \
    enum_value_v(EE, TT, YY, K0,            48) \
    enum_value_v(EE, TT, YY, K1,            49) \
    enum_value_v(EE, TT, YY, K2,            50) \
    enum_value_v(EE, TT, YY, K3,            51) \
    enum_value_v(EE, TT, YY, K4,            52) \
    enum_value_v(EE, TT, YY, K5,            53) \
    enum_value_v(EE, TT, YY, K6,            54) \
    enum_value_v(EE, TT, YY, K7,            55) \
    enum_value_v(EE, TT, YY, K8,            56) \
    enum_value_v(EE, TT, YY, K9,            57) \
    enum_value_v(EE, TT, YY, SemiColon,     59) \
    enum_value_v(EE, TT, YY, Equal,         61) \
    enum_value_v(EE, TT, YY, A,             65) \
    enum_value_v(EE, TT, YY, B,             66) \
    enum_value_v(EE, TT, YY, C,             67) \
    enum_value_v(EE, TT, YY, D,             68) \
    enum_value_v(EE, TT, YY, E,             69) \
    enum_value_v(EE, TT, YY, F,             70) \
    enum_value_v(EE, TT, YY, G,             71) \
    enum_value_v(EE, TT, YY, H,             72) \
    enum_value_v(EE, TT, YY, I,             73) \
    enum_value_v(EE, TT, YY, J,             74) \
    enum_value_v(EE, TT, YY, K,             75) \
    enum_value_v(EE, TT, YY, L,             76) \
    enum_value_v(EE, TT, YY, M,             77) \
    enum_value_v(EE, TT, YY, N,             78) \
    enum_value_v(EE, TT, YY, O,             79) \
    enum_value_v(EE, TT, YY, P,             80) \
    enum_value_v(EE, TT, YY, Q,             81) \
    enum_value_v(EE, TT, YY, R,             82) \
    enum_value_v(EE, TT, YY, S,             83) \
    enum_value_v(EE, TT, YY, T,             84) \
    enum_value_v(EE, TT, YY, U,             85) \
    enum_value_v(EE, TT, YY, V,             86) \
    enum_value_v(EE, TT, YY, W,             87) \
    enum_value_v(EE, TT, YY, X,             88) \
    enum_value_v(EE, TT, YY, Y,             89) \
    enum_value_v(EE, TT, YY, Z,             90) \
    enum_value_v(EE, TT, YY, LeftBracket,   91) \
    enum_value_v(EE, TT, YY, BackSlash,     92) \
    enum_value_v(EE, TT, YY, RightBracket,  93) \
    enum_value_v(EE, TT, YY, GraveAccent,   96) \
    enum_value_v(EE, TT, YY, World1,       161) \
    enum_value_v(EE, TT, YY, World2,       162) \
    enum_value_v(EE, TT, YY, Escape,       256) \
    enum_value_v(EE, TT, YY, Enter,        257) \
    enum_value_v(EE, TT, YY, Tab,          258) \
    enum_value_v(EE, TT, YY, Backspace,    259) \
    enum_value_v(EE, TT, YY, Insert,       260) \
    enum_value_v(EE, TT, YY, Delete,       261) \
    enum_value_v(EE, TT, YY, Right,        262) \
    enum_value_v(EE, TT, YY, Left,         263) \
    enum_value_v(EE, TT, YY, Down,         264) \
    enum_value_v(EE, TT, YY, Up,           265) \
    enum_value_v(EE, TT, YY, PageUp,       266) \
    enum_value_v(EE, TT, YY, PageDown,     267) \
    enum_value_v(EE, TT, YY, Home,         268) \
    enum_value_v(EE, TT, YY, End,          269) \
    enum_value_v(EE, TT, YY, CapsLock,     280) \
    enum_value_v(EE, TT, YY, ScrollLock,   281) \
    enum_value_v(EE, TT, YY, NumLock,      282) \
    enum_value_v(EE, TT, YY, PrintScreen,  283) \
    enum_value_v(EE, TT, YY, Pause,        284) \
    enum_value_v(EE, TT, YY, F1,           290) \
    enum_value_v(EE, TT, YY, F2,           291) \
    enum_value_v(EE, TT, YY, F3,           292) \
    enum_value_v(EE, TT, YY, F4,           293) \
    enum_value_v(EE, TT, YY, F5,           294) \
    enum_value_v(EE, TT, YY, F6,           295) \
    enum_value_v(EE, TT, YY, F7,           296) \
    enum_value_v(EE, TT, YY, F8,           297) \
    enum_value_v(EE, TT, YY, F9,           298) \
    enum_value_v(EE, TT, YY, F10,          299) \
    enum_value_v(EE, TT, YY, F11,          300) \
    enum_value_v(EE, TT, YY, F12,          301) \
    enum_value_v(EE, TT, YY, F13,          302) \
    enum_value_v(EE, TT, YY, F14,          303) \
    enum_value_v(EE, TT, YY, F15,          304) \
    enum_value_v(EE, TT, YY, F16,          305) \
    enum_value_v(EE, TT, YY, F17,          306) \
    enum_value_v(EE, TT, YY, F18,          307) \
    enum_value_v(EE, TT, YY, F19,          308) \
    enum_value_v(EE, TT, YY, F20,          309) \
    enum_value_v(EE, TT, YY, F21,          310) \
    enum_value_v(EE, TT, YY, F22,          311) \
    enum_value_v(EE, TT, YY, F23,          312) \
    enum_value_v(EE, TT, YY, F24,          313) \
    enum_value_v(EE, TT, YY, F25,          314) \
    enum_value_v(EE, TT, YY, Kp0,          320) \
    enum_value_v(EE, TT, YY, Kp1,          321) \
    enum_value_v(EE, TT, YY, Kp2,          322) \
    enum_value_v(EE, TT, YY, Kp3,          323) \
    enum_value_v(EE, TT, YY, Kp4,          324) \
    enum_value_v(EE, TT, YY, Kp5,          325) \
    enum_value_v(EE, TT, YY, Kp6,          326) \
    enum_value_v(EE, TT, YY, Kp7,          327) \
    enum_value_v(EE, TT, YY, Kp8,          328) \
    enum_value_v(EE, TT, YY, Kp9,          329) \
    enum_value_v(EE, TT, YY, KpDecimal,    330) \
    enum_value_v(EE, TT, YY, KpDivide,     331) \
    enum_value_v(EE, TT, YY, KpMultiply,   332) \
    enum_value_v(EE, TT, YY, KpSubtract,   333) \
    enum_value_v(EE, TT, YY, KpAdd,        334) \
    enum_value_v(EE, TT, YY, KpEnter,      335) \
    enum_value_v(EE, TT, YY, KpEqual,      336) \
    enum_value_v(EE, TT, YY, LeftShift,    340) \
    enum_value_v(EE, TT, YY, LeftControl,  341) \
    enum_value_v(EE, TT, YY, LeftAlt,      342) \
    enum_value_v(EE, TT, YY, LeftSuper,    343) \
    enum_value_v(EE, TT, YY, RightShift,   344) \
    enum_value_v(EE, TT, YY, RightControl, 345) \
    enum_value_v(EE, TT, YY, RightAlt,     346) \
    enum_value_v(EE, TT, YY, RightSuper,   347) \
    enum_value_v(EE, TT, YY, Menu,         348)
declare_enum(Key)

#define Exists_schema(E,T,Y,...) \
    enum_value(E,T,Y, no,     0) \
    enum_value(E,T,Y, file,   1) \
    enum_value(E,T,Y, dir,    2)
declare_enum(Exists)

forward(array)

#define vector_schema(X,Y,...) \
    i_prop(X,Y, public, Au, placeholder) \
    i_method(X,Y, public, none,    concat, ARef, num) \
    i_method(X,Y, public, ARef,    get,  num) \
    i_method(X,Y, public, none,    set,  num, ARef) \
    i_method(X,Y, public, none,    push, Au) \
    i_method(X,Y, public, vector,  slice, num, num) \
    i_method(X,Y, public, Au,       resize, sz) \
    i_method(X,Y, public, Au,       reallocate, sz) \
    i_override(X,Y, method, init) \
    i_ctr(X,Y, public, i32) \
    i_ctr(X,Y, public, path)
declare_class_2(vector, collective)

none vector_init(vector);


// let us declare our vector with string
// Au, user space is simply the cstring

#define subprocedure_schema(X,Y,...) \
    i_prop    (X,Y, required, Au, target) \
    i_prop    (X,Y, public,   Au, ctx) \
    i_prop    (X,Y, required, handle, addr) \
    i_method  (X,Y, public,   Au, invoke, Au)
declare_class(subprocedure)

#define subproc(targ, faddr, context) new(subprocedure, target, targ, ctx, context, addr, faddr) 

typedef Au(*mix_fn)(Au, Au, f32);

// keyword methods, is a simple public method idea to elevate it bracket-less status
// however, the user can define keyword interface, so we can do that.  required is just
// another one of those interfaces that are used in use-case.
#define interface_schema(E,T,Y,...) \
    enum_value       (E,T,Y, undefined,  0) \
    enum_value       (E,T,Y, intern,     1) \
    enum_value       (E,T,Y, public,     2) \
    enum_value       (E,T,Y, guard,      3) \
    enum_value       (E,T,Y, context,    4) \
    enum_value       (E,T,Y, keyword,    5)
declare_enum(interface)

#define comparison_schema(E,T,Y,...) \
    enum_value(E,T,Y, equals,            32) \
    enum_value(E,T,Y, not_equals,        33) \
    enum_value(E,T,Y, u_greater_than,    34) \
    enum_value(E,T,Y, u_greater_than_e,  35) \
    enum_value(E,T,Y, u_less_than,       36) \
    enum_value(E,T,Y, u_less_than_e,     37) \
    enum_value(E,T,Y, s_greater_than,    38) \
    enum_value(E,T,Y, s_greater_than_e,  39) \
    enum_value(E,T,Y, s_less_than,       40) \
    enum_value(E,T,Y, s_less_than_e,     41)
declare_enum(comparison)


#define array_schema(AA,Y,O,...) \
    s_vargs          (AA,Y, public, array,   array_of,       Au) \
    s_vargs          (AA,Y, public, array,   array_of_cstr,  cstr) \
    i_method         (AA,Y, public, array,   mix, array, f32) \
    i_method         (AA,Y, public, Au,      first_element) \
    i_method         (AA,Y, public, Au,      last_element) \
    i_method         (AA,Y, public, Au,      pop) \
    i_method         (AA,Y, public, array,   shift) \
    i_method         (AA,Y, public, Au,      qpush, Au) \
    i_method         (AA,Y, public, string,  join, cstr) \
    i_method         (AA,Y, public, none,    fill,           Au) \
    i_method         (AA,Y, public, array,   reverse) \
    i_method         (AA,Y, public, none,    remove,         num) \
    i_method         (AA,Y, public, none,    remove_weak,    num) \
    i_method         (AA,Y, public, none,    push,           Au) \
    i_method         (AA,Y, public, none,    push_vdata,     Au, i64) \
    i_method         (AA,Y, public, none,    push_weak,      Au) \
    i_method         (AA,Y, public, none,    clear) \
    i_method         (AA,Y, public, none,    concat,         array) \
    i_method         (AA,Y, public, Au,       get,            num) \
    i_method         (AA,Y, public, num,     count) \
    i_method         (AA,Y, public, num,     index_of,       Au) \
    i_operator       (AA,Y, public, none,    _assign_add,    Au) \
    i_operator       (AA,Y, public, none,    _assign_sub,    num) \
    i_cast           (AA,Y, public, map) \
    i_vargs          (AA,Y, public, none,    push_symbols,   cstr) \
    i_vargs          (AA,Y, public, none,    push_objects,   Au) \
    i_index          (AA,Y, public, Au,       num) \
    i_ctr            (AA,Y, public, i32) \
    i_override       (AA,Y, method, init) \
    i_override       (AA,Y, method, dealloc) \
    i_override       (AA,Y, cast,   bool) \
    i_override       (AA,Y, cast,   string)
declare_class_2(array, collective)

Exists Au_exists(Au);

#define srcfile_schema(X,Y,...) \
    i_prop           (X,Y, public, Au, obj) \
    i_ctr            (X,Y, public, Au) \
    i_override       (X,Y, cast,   string)
declare_class(srcfile)

extern int fault_level;

#define level_schema(E,T,Y,...) \
    enum_value(E,T,Y, information, 0) \
    enum_value(E,T,Y, warn,        1) \
    enum_value(E,T,Y, err,         2)
declare_enum(level)

#define map_schema(X,Y,...) \
    i_method    (X,Y, public,  none,       set,        Au, Au) \
    i_method    (X,Y, public,  Au,         get,        Au) \
    i_method    (X,Y, public,  Au,         value_by_index, num) \
    i_method    (X,Y, public,  item,       lookup,     Au) \
    i_method    (X,Y, public,  item,       fetch,      Au) \
    i_method    (X,Y, public,  none,       rm,         Au) \
    i_method    (X,Y, public,  none,       rm_item,    item) \
    i_method    (X,Y, public,  bool,       contains,   Au) \
    i_method    (X,Y, public,  none,       concat,     map) \
    i_method    (X,Y, public,  none,       clear) \
    i_index     (X,Y, public,  Au,         sz) \
    i_index     (X,Y, public,  Au,         Au) \
    i_ctr       (X,Y, public,  i32) \
    i_override  (X,Y, method,  init) \
    i_override  (X,Y, method,  dealloc) \
    i_override  (X,Y, cast,    string) \
    i_override  (X,Y, cast,    bool) \
    i_override  (X,Y, method,  copy)
declare_class_2(map, collective)

#define ctx_schema(X,Y,...) \
    i_prop(X,Y, public, Au, app) \
    i_prop(X,Y, intern, bool,   establishing, pad, 32)
declare_class_3(ctx, map, collective)

#define ipart_schema(AA,Y,...) \
    i_prop    (AA,Y,   public, bool,   is_expr) \
    i_prop    (AA,Y,   public, string, content)
declare_class(ipart)


#define string_schema(AA,Y,...) \
    i_prop    (AA,Y,   public, symbol,  chars) \
    i_prop    (AA,Y,   public, num,     alloc) \
    i_prop    (AA,Y,   public, num,     ref_length) \
    i_prop    (AA,Y,   public, num,     count) \
    i_prop    (AA,Y,   public, u64,     h) \
    i_method  (AA,Y,   public, bool,    is_numeric) \
    i_method  (AA,Y,   public, i32,     first) \
    i_method  (AA,Y,   public, i32,     last) \
    i_method  (AA,Y,   public, f64,     real_value) \
    i_guard   (AA,Y,   public, sz,      len) \
    i_method  (AA,Y,   public, string,  ucase) \
    i_method  (AA,Y,   public, string,  lcase) \
    i_method  (AA,Y,   public, array,   split, symbol) \
    i_method  (AA,Y,   public, string,  escape) \
    i_method  (AA,Y,   public, num,     index_of, symbol) \
    i_method  (AA,Y,   public, num,     rindex_of, symbol) \
    i_method  (AA,Y,   public, none,    append, symbol) \
    i_method  (AA,Y,   public, none,    append_count, symbol, i32) \
    i_method  (AA,Y,   public, none,    push, u32) \
    i_method  (AA,Y,   public, none,    concat, string) \
    i_method  (AA,Y,   public, string,  trim) \
    i_method  (AA,Y,   public, string,  ltrim) \
    i_method  (AA,Y,   public, string,  rtrim) \
    i_method  (AA,Y,   public, string,  mid, num, num) \
    i_method  (AA,Y,   public, none,    reserve, num) \
    i_method  (AA,Y,   public, none,    writef, handle, bool) \
    i_method  (AA,Y,   public, bool,    ends_with, symbol) \
    i_method  (AA,Y,   public, bool,    starts_with, symbol) \
    i_method  (AA,Y,   public, num,     cmp, symbol) \
    i_method  (AA,Y,   public, bool,    eq,  symbol) \
    i_method  (AA,Y,   public, string,  interpolate, Au) \
    i_method  (AA,Y,   public, array,   split_parts) \
    i_cast    (AA,Y,   public, cstr) \
    i_cast    (AA,Y,   public, sz) \
    i_cast    (AA,Y,   public, path) \
    i_ctr     (AA,Y,   public, symbol) \
    i_ctr     (AA,Y,   public, cstr) \
    i_ctr     (AA,Y,   public, i32) \
    i_operator(AA,Y,   public, none,   _assign_add,  string) \
    i_operator(AA,Y,   public, string, _add,         string) \
    i_index   (AA,Y,   public, i32, num) \
    i_override(AA,Y,   method, hash) \
    i_override(AA,Y,   method, compare) \
    i_override(AA,Y,   method, init) \
    i_override(AA,Y,   cast,   bool) \
    i_override(AA,Y,   method, copy)
declare_class(string)


#define const_string_schema(AA,Y,...)
declare_class_2(const_string, string)

#define command_schema(X,Y,...) \
    i_method  (X,Y, public, i32,    exec) \
    i_method  (X,Y, public, string, run) \
    s_method  (X,Y, public, i64, last_pid) \
    i_override(X,Y, ctr, cstr)
declare_class_2(command, string)

#define watch_schema(X,Y,...) \
    i_prop      (X,Y, public, path, res) \
    i_prop      (X,Y, public, ARef, callback) \
    i_prop      (X,Y, public, ARef, argument) \
    i_method    (X,Y, public, none, pause) \
    i_method    (X,Y, public, none, start) \
    i_override  (X,Y, method, init)
declare_class(watch)

#define mutex_schema(X,Y,...) \
    i_prop      (X,Y, public, bool, cond) \
    i_method    (X,Y, public, none, lock) \
    i_method    (X,Y, public, none, unlock) \
    i_method    (X,Y, public, none, cond_wait) \
    i_method    (X,Y, public, none, cond_signal) \
    i_method    (X,Y, public, none, cond_broadcast) \
    i_prop      (X,Y, intern, struct mutex_t*, mtx, as, ARef) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, method, dealloc)
declare_class(mutex)

#define async_schema(X,Y,...) \
    i_prop      (X,Y, public, hook,     work_fn) \
    i_prop      (X,Y, public, array,    work) \
    i_prop      (X,Y, intern, mutex,    global) \
    i_prop      (X,Y, intern, struct thread_t*, threads, as, ARef) \
    i_method    (X,Y, public, Au,   sync, Au) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, method, dealloc)
declare_class(async)

#define token_schema(X,Y,...) \
    i_prop      (X,Y,  public,  path,       source) \
    i_prop      (X,Y,  public,  num,        line) \
    i_prop      (X,Y,  public,  num,        column) \
    i_prop      (X,Y,  public,  num,        indent) \
    i_prop      (X,Y,  public,  Au,          literal) \
    i_prop      (X,Y,  public,  bool,      cmode) \
    i_method    (X,Y,  public,  Au_t,      get_type) \
    i_method    (X,Y,  public,  string,     location) \
    i_override  (X,Y,  ctr,     cstr) \
    i_override  (X,Y,  method,  init) \
    i_override  (X,Y,  method,  copy)
declare_class_2(token, string)

#define tokens_schema(X,Y,...) \
    i_prop      (X,Y,  required,  callback_extra, parser) \
    i_prop      (X,Y,  required,  Au, target) \
    i_prop      (X,Y,  required,  Au, input) \
    i_ctr       (X,Y,  public, cstr) \
    i_override  (X,Y,  method, init)
declare_class_3(tokens, array, collective)
 
#define path_schema(X,Y,...) \
    i_method    (X,Y, public, bool,   exists) \
    i_method    (X,Y, public, bool,   touch) \
    i_method    (X,Y, public, bool,   create_symlink, path) \
    i_method    (X,Y, public, bool,   is_symlink) \
    i_method    (X,Y, public, path,   resolve) \
    i_method    (X,Y, public, bool,   make_dir) \
    i_method    (X,Y, public, bool,   remove_dir) \
    i_method    (X,Y, public, bool,   is_ext, symbol) \
    i_method    (X,Y, public, bool,   is_empty) \
    i_method    (X,Y, public, bool,   is_dir) \
    i_method    (X,Y, public, none,   cp, path, bool, bool) \
    i_method    (X,Y, public, path,   directory) \
    i_method    (X,Y, public, none,   cd) \
    i_method    (X,Y, public, string, stem) \
    i_method    (X,Y, public, string, ext) \
    i_method    (X,Y, public, string, mime) \
    i_method    (X,Y, public, string, base64) \
    i_method    (X,Y, public, string, filename) \
    i_method    (X,Y, public, path,   absolute) \
    i_method    (X,Y, public, path,   parent_dir) \
    i_method    (X,Y, public, Au,      load, Au_t, ctx) \
    i_method    (X,Y, public, bool,   save, Au,     ctx) \
    i_method    (X,Y, public, path,   change_ext, cstr) \
    i_method    (X,Y, public, array,  ls, string, bool) \
    i_method    (X,Y, public, bool,   move, path) \
    i_method    (X,Y, public, path,   latest_modified, ARef) \
    i_method    (X,Y, public, i64,    modified_time) \
    i_method    (X,Y, public, i64,    wait_for_change, i64, i64) \
    s_method    (X,Y, public, path,   self) \
    s_method    (X,Y, public, path,   share_path) \
    s_method    (X,Y, public, path,   cwd) \
    s_method    (X,Y, public, path,   tempfile, symbol) \
    i_ctr       (X,Y, public, string) \
    i_ctr       (X,Y, public, tokens) \
    i_override  (X,Y, method,   hash) \
    i_override  (X,Y, method,   init) \
    i_override  (X,Y, method,   eq) \
    i_override  (X,Y, ctr,      symbol) \
    i_override  (X,Y, ctr,      cstr) \
    i_override  (X,Y, cast,     cstr) \
    i_override  (X,Y, cast,     sz) \
    i_override  (X,Y, cast,     bool) \
    i_override  (X,Y, cast,     string)
declare_class_2(path, string)



#define subscriber_schema(X,Y,...) \
    i_prop    (X,Y, required, Au,   target) \
    i_prop    (X,Y, required, callback, method)
declare_class(subscriber)

#define subs_schema(X,Y,...) \
    i_prop    (X,Y, public,   array,  entries, meta, subscriber) \
    i_method  (X,Y, public,   none,   add,    Au, callback) \
    i_method  (X,Y, public,   Au, invoke, Au)
declare_class(subs)


#define line_schema(X,Y,...) \
    i_prop(X,Y, public, i32, indent) \
    i_prop(X,Y, public, array, text)
#undef line_intern
#define line_intern(X,Y,...) line_schema(X,Y,__VA_ARGS__)
declare_class(line)

extern FILE* logger;

cstr copy_cstr(cstr input);

/// useful utility for smooth movement of any variable in a variable-step-rate
/// used in Hyper Race physics to make adjustments to cars at frame-rate
static inline f32 filter_n(f32 current, f32 goal, f32 amount, f32 rate) {
    f32 decay = powf(1.0f - amount, rate);
    if (goal != 0.0f)
        return current + ((goal - current) * (1.0f - decay));
    else
        return current * decay;
}

Au      _i8(i8);
Au      _u8(u8);
Au      _i16(i16);
Au      _u16(u16);
Au      _i32(i32);
Au      _u32(u32);
Au      _i64(i64);
Au          i(i64);
Au      _sz(sz);
Au      _u64(u64);
Au      _f32(f32);
Au      _f64(f64);
Au      _fp16(fp16*);
Au      _bf16(bf16*);
Au  float32(f32);
Au   real64(f64);
Au      _cstr(cstr);
Au      _none();
Au      _bool(bool);

string json(Au a);

//#define array_string_schema(X,Y,...)
//declare_class_2(array_string,     array, string)

//#define array_map_schema(X,Y,...)
//declare_class_2(array_map,        array, map)

static inline f32 f32_mix(f32 a, f32 b, f32 f) {
    return a * (1.0f - f) + b * f;
}

/// use i_struct_ctr_obj for objects or primitives
/// use i_struct_ctr for structs.. this is because we cannot separate * from the token
#define vec_methods(O, Y, T, ...) \
    i_struct_ctr_obj(O,Y, floats) \
    i_struct_method(O, Y, T,    length) \
    i_struct_method(O, Y, O,    add,      O*) \
    i_struct_method(O, Y, O,    sub,      O*) \
    i_struct_method(O, Y, O,    mul,      O*) \
    i_struct_method(O, Y, O,    scale,    f32) \
    i_struct_method(O, Y, T,    dot,      O*) \
    i_struct_method(O, Y, O,    normalize) \
    i_struct_method(O, Y, O,    mix,      O*, f64) \
    i_struct_cast  (O, Y, string)

#define rgb8_schema(O, Y, ...) \
    i_struct_prop(O,Y,u8, r) \
    i_struct_prop(O,Y,u8, g) \
    i_struct_prop(O,Y,u8, b)
declare_struct(rgb8)

#define rgbf_schema(O, Y, ...) \
    i_struct_prop(O,Y, f32, r) \
    i_struct_prop(O,Y, f32, g) \
    i_struct_prop(O,Y, f32, b)
declare_struct(rgbf)

#define rgba8_schema(O, Y, ...) \
    i_struct_prop(O,Y,u8, r) \
    i_struct_prop(O,Y,u8, g) \
    i_struct_prop(O,Y,u8, b) \
    i_struct_prop(O,Y,u8, a)
declare_struct(rgba8)

#define rgba16_schema(O, Y, ...) \
    i_struct_prop(O,Y,u16, r) \
    i_struct_prop(O,Y,u16, g) \
    i_struct_prop(O,Y,u16, b) \
    i_struct_prop(O,Y,u16, a)
declare_struct(rgba16)

typedef struct _vec3f vec3f;

#define vec4f_schema(O, Y, T, ...) \
    i_struct_ctr(O,Y, vec3f) \
    i_struct_prop  (O, Y, T, x) \
    i_struct_prop  (O, Y, T, y) \
    i_struct_prop  (O, Y, T, z) \
    i_struct_prop  (O, Y, T, w) \
    vec_methods(O, Y, T, __VA_ARGS__)
declare_struct(vec4f, f32)

#define rgbaf_schema(O, Y, ...) \
    i_struct_ctr(O,Y, vec4f) \
    i_struct_prop(O,Y, f32, r) \
    i_struct_prop(O,Y, f32, g) \
    i_struct_prop(O,Y, f32, b) \
    i_struct_prop(O,Y, f32, a)
declare_struct(rgbaf)

#define vec3f_schema(O, Y, T, ...) \
    i_struct_prop  (O, Y, T, x) \
    i_struct_prop  (O, Y, T, y) \
    i_struct_prop  (O, Y, T, z) \
    i_struct_method(O, Y, O, cross, O*) \
    i_struct_static(O, Y, O, rand) \
    vec_methods(O, Y, T)
declare_struct(vec3f, f32)

#define quatf_schema(O, Y, ...) \
    i_struct_ctr(O,Y, vec4f) \
    i_struct_prop(O,Y,f32, x) \
    i_struct_prop(O,Y,f32, y) \
    i_struct_prop(O,Y,f32, z) \
    i_struct_prop(O,Y,f32, w)
declare_struct(quatf)

#define rgba_schema(O, Y, ...) \
    i_prop(O,Y, public, f32, r) \
    i_prop(O,Y, public, f32, g) \
    i_prop(O,Y, public, f32, b) \
    i_prop(O,Y, public, f32, a) \
    i_method(O,Y, public, rgba, mix, rgba, f32) \
    i_ctr(O,Y, public, cstr) \
    i_ctr(O,Y, public, string)
declare_class(rgba)

f32 degrees(f32 rads);
f32 radians(f32 degs);


#define vec2f_schema(O, Y, T, ...) \
    i_struct_prop (O, Y, T, x) \
    i_struct_prop (O, Y, T, y) \
    vec_methods   (O, Y, T, __VA_ARGS__)
declare_struct(vec2f, f32)

#define rect_schema(O, Y, ...) \
    i_prop (O, Y, public, f32, x) \
    i_prop (O, Y, public, f32, y) \
    i_prop (O, Y, public, f32, w) \
    i_prop (O, Y, public, f32, h) \
    i_method(O, Y, public, vec2f, xy) \
    s_method(O, Y, public, rect, create_rect, vec2f, vec2f)
declare_class(rect)

#define mat4f_schema(O, Y, T, ...) \
    i_struct_array  (O, Y, f32,   16, m) \
    i_struct_ctr_obj(O, Y, floats) \
    i_struct_ctr    (O, Y, quatf) \
    i_struct_method (O, Y, O,        inverse) \
    i_struct_method (O, Y, O,        transpose) \
    i_struct_static (O, Y, O,        identity) \
    i_struct_static (O, Y, O,        perspective, f32, f32, f32, f32) \
    i_struct_static (O, Y, O,        ortho,      f32, f32, f32, f32, f32, f32) \
    i_struct_static (O, Y, O,        look_at,    vec3f*, vec3f*, vec3f*) \
    i_struct_method (O, Y, O,        scale,      vec3f*) \
    i_struct_method (O, Y, O,        translate,  vec3f*) \
    i_struct_method (O, Y, O,        rotate,     quatf*) \
    i_struct_method (O, Y, vec4f,    mul_v4,     vec4f*) \
    i_struct_method (O, Y, none,     set_identity) \
    i_struct_method (O, Y, O,        mul,        O*) \
    i_struct_cast   (O, Y, string)
declare_struct(mat4f, f32)


// will need to adjust json serialization to facilitate vector with meta types
#define vector_mat4f_schema(X,Y,...)
declare_class_3(vector_mat4f, vector, collective, mat4f)

#define vector_vec4f_schema(X,Y,...)
declare_class_3(vector_vec4f, vector, collective, vec4f)

#define vector_vec3f_schema(X,Y,...)
declare_class_3(vector_vec3f, vector, collective, vec3f)

#define vector_vec2f_schema(X,Y,...)
declare_class_3(vector_vec2f, vector, collective, vec2f)

#define vector_i8_schema(X,Y,...)
declare_class_3(vector_i8, vector, collective, i8)

#define vector_f32_schema(X,Y,...)
declare_class_3(vector_f32, vector, collective, f32)

#define vector_f64_schema(X,Y,...)
declare_class_3(vector_f64, vector, collective, f64)

#define vector_i64_schema(X,Y,...)
declare_class_3(vector_i64, vector, collective, i64)

#define vector_rgba8_schema(X,Y,...)
declare_class_3(vector_rgba8, vector, collective, rgba8)

#define vector_rgba16_schema(X,Y,...)
declare_class_3(vector_rgba16, vector, collective, rgba16)

#define vector_rgbaf_schema(X,Y,...)
declare_class_3(vector_rgbaf, vector, collective, rgbaf)

#define vector_rgb8_schema(X,Y,...)
declare_class_3(vector_rgb8, vector, collective, rgb8)

#define vector_rgbf_schema(X,Y,...)
declare_class_3(vector_rgbf, vector, collective, rgbf)

vector_f32   vector_f32_new  (shape count, ...);
vector_f64   vector_f64_new  (shape count, ...);
vector_i8    vector_i8_new   (shape count, ...);
vector_i64   vector_i64_new  (shape count, ...);
vector_rgba16 vector_rgba16_new(shape count, ...);
vector_rgba8 vector_rgba8_new(shape count, ...);
vector_rgbaf vector_rgbaf_new(shape count, ...);
vector_rgb8  vector_rgb8_new (shape count, ...);
vector_rgbf  vector_rgbf_new (shape count, ...);

none set_meta_array(Au_t type, int count, ...);
none set_meta_map(Au_t type, int count, ...);
Au_t meta_index(Au a, int i);

none array_init(array);

Au_t au_arg(Au a);

#define weak_schema(X,Y,...)
declare_abstract(weak)

#define functional_schema(X,Y,...)
declare_abstract(functional)

#define cast(T,I) fcall(I, cast_##T)

none halt(string);

#ifdef __cplusplus
}
#endif

#endif