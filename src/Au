#ifndef _Au_
#define _Au_

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#ifndef _WIN32
#include <libgen.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#endif
#include <math.h>
#include <setjmp.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950288
#endif

#define forward(t) typedef struct _##t* t;


#ifdef __cplusplus
extern "C" {
#endif

typedef struct _Au_t *Au_t;

struct _array;
struct _Au_t;

//#define len(I,...) ({ __typeof__(I) _i_ = I; _i_ ? (num)ftableI(_i_)->ft.len((collective)_i_, ## __VA_ARGS__) : (num)0; })


#undef bool
#undef false
#undef true

#define true                (bool)1
#define false               (bool)0
#define stringify(x)               stringify_actual(x)
#define stringify_actual(x)        #x
#ifdef __cplusplus
#define null                nullptr
#else
#define null                ((void*)0)
#endif
#define FNV_PRIME           0x100000001b3
#define OFFSET_BASIS        0xcbf29ce484222325

forward(string)

typedef struct __error_t {
    jmp_buf env;
    struct __error_t* prev;
    string message;
} __error_t;

extern __thread __error_t* Au_error_top;

#define attempt() \
    { \
        __error_t _frame; \
        _frame.prev = Au_error_top; \
        Au_error_top = &_frame; \
        if (setjmp(_frame.env) == 0)

#define on_error() \
    else

#define finally() \
        Au_error_top = _frame.prev; \
    }


void toss(string msg);

/// Au runtime
typedef void                    none;
typedef signed char             i8;
typedef short                   i16;
typedef int                     i32;
typedef long long               i64;
typedef unsigned char           u8;
typedef unsigned short          u16;
typedef unsigned int            u32;
typedef unsigned long long      u64;

typedef u64                     AF;
typedef long long               num;
typedef long long               sz;      /// a signed 64 bit size lets us act like python, so this is a type for the purpose of indexing and all valid sizes
#ifndef __cplusplus
typedef u8                      bool;
#endif
typedef float                   f32;
typedef double                  f64;
typedef double                  real;    /// real enough
typedef void*                   handle;
typedef char*                   cstr;
typedef const char*             symbol;
typedef bool                   *ref_bool;

typedef __fp16                  fp16;
typedef __bf16                  bf16;


typedef struct cereal { char* value; } cereal;

// typedef struct _object*         Au;
typedef struct _Au**             ARef; /// registered for a generic raw, but we must transition to use 'raw' in cases where they are not Au-allocations
typedef float*                  floats;
typedef cstr*                   cstrs;
typedef void*                   raw;        // abstract types are void*
typedef void*                   numeric;


#include <object.h>

#undef assert
#include <macros.h>


typedef signed char            *ref_i8;
typedef short                  *ref_i16;
typedef int                    *ref_i32;
typedef long long              *ref_i64;
typedef unsigned char          *ref_u8;
typedef unsigned short         *ref_u16;
typedef unsigned int           *ref_u32;
typedef unsigned long long     *ref_u64;
typedef float                  *ref_f32;
typedef double                 *ref_f64;





#define Au_f_members(B) \
    Au_t            context; \
    union { Au_t src, rtype, type; }; \
    Au_t            schema; \
    Au              user; \
    Au_t            module; \
    Au_t            ptr; \
    char*           ident; \
    char*           alt; \
    u32             abi_size; \
    u32             align_bits; \
    u32             record_alignment; \
    ARef            llscope; \
    ARef            lltype; \
    ARef            lldebug; \
    i64             index; \
    object          value; \
    u8              member_type; \
    u8              operator_type; \
    u8              access_type; \
    u8              reserved; \
    u64             traits; \
    int             global_count; \
    int             offset; \
    int             elements; \
    int             typesize; \
    int             isize; \
    void*           fn; \
    ffi_method_t*   ffi; \
    au_core         af; \
    struct _object  members_info; \
    struct _collective_abi  members; \
    struct _object  meta_info; \
    struct _collective_abi  meta; \
    struct _shape*  shape; \
    u64             required_bits[2];

#define declare_typedef(X) \
    typedef struct _ ## X* X;

#define decl_type(AA) \
    typedef struct _##AA##_info { \
        struct _Au     info; \
        AA##_f        type; \
    } AA##_info; \
    extern AA##_info   AA##_i; \

#define declare_base( AA ) \
    declare_typedef(AA) \
    _Pragma("pack(push, 1)") \
    struct AA ## _fields { \
        u8 __none__; \
    }; \
    typedef struct _ ## AA { \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL) \
    typedef struct _##AA##_f { \
        Au_f_members(Au) \
        struct { void(*_ff)(); \
            AA##_schema (AA, METHOD) \
        } ft; \
    } AA##_f; \
    typedef struct _##AA##_t_info { \
        struct _Au     info; \
        struct _##AA##_t_ { \
            Au_f_members(Au) \
        } type; \
    } AA##_t_info; \
    extern AA##_t_info   AA##_t_i; \
    decl_type(AA) \
    _Pragma("pack(pop)")

// a void* is abstract enough
#define declare_abstract( X, ... ) \
    _Pragma("pack(push, 1)") \
    typedef void* X; \
    typedef struct _##X##_f { \
        Au_f_members(Au) \
        struct { void(*_ff)(); \
            Au_schema(Au, METHOD) \
            X##_schema(X, METHOD, __VA_ARGS__) \
        } ft; \
    } X##_f, *X##_ft; \
    decl_type(X) \
    _Pragma("pack(pop)") \


#define declare_primitive( AA, Y, ... ) \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA##_f { \
        Au_f_members(Au) \
        struct { void(*_ff)(); \
            Au_schema(Au, METHOD, __VA_ARGS__) \
            AA##_schema(AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define ENUM_COUNT(...)  (sizeof((int[]){__VA_ARGS__}) / sizeof(int))

// can technically use enums to phone home with real numbers
#define declare_typed_enum( E, T ) \
    typedef T E; \
    E##_schema(E, T, DECL) \
    _Pragma("pack(push, 1)") \
    typedef struct _##E##_f { \
        Au_f_members(Au) \
        struct { \
            Au_schema   (Au, METHOD) \
            E##_schema (Au, T, METHOD) \
        } ft; \
    } E##_f, *E##_ft; \
    static const i32 E##_ENUM_COUNT = ENUM_COUNT(E##_schema(E, T, COUNT)); \
    decl_type(E)\
    _Pragma("pack(pop)") \

#define declare_enum( E ) declare_typed_enum(E, i32)

void lazy_init(global_init_fn fn, Au_t);

#define define_typed_enum( E, T ) \
    E##_info E##_i;\
    static __attribute__((constructor)) bool global_##E() { \
        E ## _i.info.type = (Au_t)&E ## _i.type; \
        E ## _i.info.refs = 1000; \
        E ## _f* type_ref = &E ## _i.type; \
        Au_t base_ref     = (Au_t)&Au_i.type; \
        if ((Au_t)type_ref != (Au_t)base_ref && base_ref->typesize == 0) { \
            lazy_init((global_init_fn)&global_##E, (Au_t)base_ref); \
            return false; \
        } else { \
            memset(type_ref, 0, sizeof(E##_i.type)); \
            memcpy(&type_ref->ft, &base_ref->ft, sizeof(__typeof__(base_ref->ft))); \
            /*type_ref->type = typeid(Au_t_f); */ \
            type_ref->members.alloc     = 64; \
            type_ref->members.assorted  = true; \
            type_ref->members.unmanaged = true; \
            array_init((array)&type_ref->members); \
            type_ref->meta.alloc        = 16; \
            type_ref->meta.assorted  = true; \
            type_ref->meta.unmanaged = true; \
            array_init((array)&type_ref->meta); \
            type_ref->src      = typeid(T); \
            type_ref->context   = (__typeof__(E##_i.type.context))& Au_i.type; \
            type_ref->ident    = #E;                 \
            type_ref->module   = module_lookup(MODULE); \
            type_ref->typesize     = sizeof(E);          \
            type_ref->traits   = AU_TRAIT_IS_AU | AU_TRAIT_ENUM; \
            head(type_ref)->type = typeid(Au_t_f); \
            E##_schema( E, T, IMPL ); \
            push_type((Au_t)type_ref); \
            return true; \
        } \
    }


#define define_enum( E ) \
    define_typed_enum(E, i32)

#define FIELD_ID(TYPE, MEMBER) offsetof(struct TYPE##_fields, MEMBER)

#define declare_class\
(AA, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        AA##_intern (AA, F, __VA_ARGS__) \
        void* __none__; \
    }; \
    typedef struct _##AA { \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        u8 AA##_interns [0 AA##_intern(AA, ISIZE, __VA_ARGS__)]; \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            Au_schema(AA, METHOD, __VA_ARGS__) \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")


#define declare_class_2\
(AA, BB, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
        void* __none__; \
    }; \
    typedef struct _##AA { \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        u8 BB##_interns [0 BB##_intern (BB, ISIZE, __VA_ARGS__)]; \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        u8 AA##_interns [0 AA##_intern (AA, ISIZE, __VA_ARGS__)]; \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            Au_schema(AA, METHOD, __VA_ARGS__) \
            BB##_schema (AA, METHOD, __VA_ARGS__) \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define declare_class_3\
(AA, BB, CC, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        CC##_intern (CC, F, __VA_ARGS__) \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
        void* __none__; \
    }; \
    typedef struct _##AA { \
        CC##_intern (CC, INST_U, __VA_ARGS__) \
        CC##_intern (CC, INST_L, __VA_ARGS__) \
        u8 CC##_interns [0 CC##_intern (CC, ISIZE, __VA_ARGS__)]; \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        u8 BB##_interns [0 BB##_intern (BB, ISIZE, __VA_ARGS__)]; \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        u8 AA##_interns [0 AA##_intern (AA, ISIZE, __VA_ARGS__)]; \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            Au_schema(AA, METHOD, __VA_ARGS__) \
            CC##_schema (AA, METHOD, __VA_ARGS__) \
            BB##_schema (AA, METHOD, __VA_ARGS__) \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

// emit A-type compatible structs
// we may ALSO emit Au macros as well, however its slightly hacky in nature
// because we need t
#define declare_class_4\
(AA, BB, CC, DD, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        DD##_intern (DD, F, __VA_ARGS__) \
        CC##_intern (CC, F, __VA_ARGS__) \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
        void* __none__; \
    }; \
    typedef struct _##AA { \
        DD##_intern (DD, INST_U, __VA_ARGS__) \
        DD##_intern (DD, INST_L, __VA_ARGS__) \
        u8 DD##_interns [0 DD##_intern (DD, ISIZE, __VA_ARGS__)]; \
        CC##_intern (CC, INST_U, __VA_ARGS__) \
        CC##_intern (CC, INST_L, __VA_ARGS__) \
        u8 CC##_interns [0 CC##_intern (CC, ISIZE, __VA_ARGS__)]; \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        u8 BB##_interns [0 BB##_intern (BB, ISIZE, __VA_ARGS__)]; \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        u8 AA##_interns [0 AA##_intern (AA, ISIZE, __VA_ARGS__)]; \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            Au_schema(AA, METHOD, __VA_ARGS__) \
            DD##_schema (AA, METHOD, __VA_ARGS__) \
            CC##_schema (AA, METHOD, __VA_ARGS__) \
            BB##_schema (AA, METHOD, __VA_ARGS__) \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define arg_count_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define arg_count(...) arg_count_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define declare_base_meta\
(AA, BASE, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        BASE##_intern (AA, INST, __VA_ARGS__) \
        struct _##AA##_f* __f[2]; \
    } *AA; \
    typedef struct _##AA##_f { \
        Au_f_members(BASE) \
        struct { void(*_ff)(); \
            BASE##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define declare_struct\
(AA,...) \
    typedef struct _##AA AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        AA##_schema (AA, INST, __VA_ARGS__) \
    } AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        Au_f_members(AA) \
        struct { void(*_ff)(); \
            AA##_schema (AA, METHOD, __VA_ARGS__) \
        } ft; \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define initializer(fn) \
    static bool _initializer() { \
        fn(); \
        return true; \
    } \
    static __attribute__((constructor)) void _module_register() { \
        def_init((global_init_fn)&_initializer); \
    }


void* primitive_ffi_arb(Au_t);

typedef Au_t* Au_ts;

#ifndef NDEBUG
#define IS_DEBUG 0
#else
#define IS_DEBUG 1
#endif

#define define_arb(TYPE, BASE, TYPE_SZ, TRAIT, ...) \
    _Pragma("pack(push, 1)") \
    static au_core TYPE##_af; \
    TYPE##_info TYPE##_i; \
    _Pragma("pack(pop)") \
    static __attribute__((constructor)) bool Aglobal_##TYPE() { \
        TYPE##_f* type_ref = &TYPE##_i.type; \
        BASE##_f* base_ref = &BASE##_i.type; \
        if ((Au_t)type_ref != (Au_t)base_ref && (!base_ref->traits)) { \
            lazy_init((global_init_fn)&Aglobal_##TYPE, (Au_t)base_ref); \
            return false; \
        } else { \
            memset(type_ref, 0, sizeof(TYPE##_i.type)); \
            if ((Au_t)type_ref != (Au_t)base_ref) \
                memcpy(&type_ref->ft, &base_ref->ft, sizeof(BASE##_i.type.ft)); \
            type_ref->member_type       = AU_MEMBER_TYPE; \
            type_ref->members.alloc     = 128; \
            type_ref->members.assorted  = true; \
            type_ref->members.unmanaged = true; \
            array_init((array)&type_ref->members); \
            type_ref->meta.alloc        = 16; \
            type_ref->meta.assorted     = true; \
            type_ref->meta.unmanaged    = true; \
            array_init((array)&type_ref->meta); \
            type_ref->ident             = #TYPE; \
            type_ref->isize             = 0 TYPE##_schema( TYPE, ISIZE_EXTERN, __VA_ARGS__ ); \
            type_ref->context           = (__typeof__(type_ref->context))&BASE##_i.type; \
            type_ref->module            = module_lookup((cstr)MODULE); \
            type_ref->typesize          = TYPE_SZ; \
            type_ref->traits            = AU_TRAIT_IS_AU | TRAIT; \
            head(type_ref)->type = typeid(Au_t_f); \
            set_meta_array((Au_t)type_ref, emit_types(__VA_ARGS__)); \
            TYPE##_schema( TYPE, INIT, __VA_ARGS__ ); \
            push_type((Au_t)type_ref); \
            return true; \
        } \
    } \

#define define_any(A0, A1, SZ, traits, ...) \
    define_arb(A0, A1, SZ, traits, __VA_ARGS__)

#define define_class(A0, A1, ...) \
    define_any(A0, A1, sizeof(struct _##A0), AU_TRAIT_CLASS, __VA_ARGS__)

#define define_struct(A0, ...) \
    define_any(A0, A0, sizeof(struct _##A0), AU_TRAIT_STRUCT, __VA_ARGS__)

#define define_primitive(A0, A1, traits, ...) \
    define_any(A0, A1, sizeof(A0), traits | AU_TRAIT_PRIMITIVE, __VA_ARGS__)

#define define_abstract(A0, traits, ...) \
    define_any(A0, Au, 0, traits | AU_TRAIT_ABSTRACT, __VA_ARGS__)

struct _sz { i64 value; };


// true utility / internal functions
num clamp(num i, num mn, num mx);
real clampf(real, real, real);
i64 epoch_millis();
Au Au_initialize(Au);
none Au_init_recur(Au a, Au_t current, raw last_init);

/// Au properties are not user-accessible, 
/// so they are declared as opaque
/// the methods Are, accessible

forward(ctx)
forward(array)
forward(map)
forward(string)
forward(path)
forward(vector)
forward(any)


// Au must generate defines for sizes for users of it
#define Au_schema(AA,BB,...) \
    M(AA,BB, i, prop, intern, Au_t, type) \
    M(AA,BB, i, prop, intern, Au_t, scalar) \
    M(AA,BB, i, prop, intern, i64, refs) \
    M(AA,BB, i, prop, intern, Au, data) \
    M(AA,BB, i, prop, intern, shape, shape) \
    M(AA,BB, i, prop, intern, cstr, source) \
    M(AA,BB, i, prop, intern, i64, line) \
    M(AA,BB, i, prop, intern, i64, alloc) \
    M(AA,BB, i, prop, intern, i64, count) \
    M(AA,BB, i, prop, intern, i64, recycle) \
    M(AA,BB, i, prop, intern, i64, af_index) \
    M(AA,BB, i, array, intern, Au, 8, meta) \
    M(AA,BB, i, method, public, none,   init) \
    M(AA,BB, i, method, public, none,   dealloc) \
    M(AA,BB, i, method, public, i32,    compare, AA) \
    M(AA,BB, i, method, public, u64,    hash) \
    M(AA,BB, i, method, public, AA,     copy) \
    M(AA,BB, i, guard,  public, sz, len, Au) \
    M(AA,BB, i, method, public, callback, binding,   Au, bool, Au_t, Au_t, symbol, symbol) \
    M(AA,BB, i, method, public, ref_u64, AF_bits) \
    M(AA,BB, i, method, public, none,   AF_set_id,      i32) \
    M(AA,BB, i, method, public, none,   AF_set_name,    cstr) \
    M(AA,BB, i, method, public, i32,    AF_query_name,  cstr) \
    M(AA,BB, i, guard,  public, Au,     instance_of,    Au, Au_t) \
    M(AA,BB, i, guard,  public, AA,     hold,           Au) \
    M(AA,BB, i, guard,  public, none,   drop,           Au) \
    M(AA,BB, i, method, public, none,   hold_members) \
    M(AA,BB, i, method, public, none,   drop_members) \
    M(AA,BB, i, method, public, Au,     set_property,   symbol, Au) \
    M(AA,BB, i, method, public, Au,     get_property,   symbol) \
    M(AA,BB, i, method, public, Au,     vrealloc,       sz) \
    M(AA,BB, i, method, public, Au_t,   meta_index,     i32) \
    M(AA,BB, s, method, public, Au_t,   emplace_type, Au_t, Au_t, Au_t, Au_t, symbol, u64, u64, u64) \
    M(AA,BB, s, method, public, Au_t,   def,            Au_t, symbol, u32, u64) \
    M(AA,BB, s, method, public, Au_t,   def_func,       Au_t, symbol, Au_t, u32, u32, u32, u64, ARef) \
    M(AA,BB, s, method, public, Au_t,   def_arg,        Au_t, symbol, Au_t) \
    M(AA,BB, s, method, public, Au_t,   def_meta,       Au_t, symbol, Au_t) \
    M(AA,BB, s, method, public, Au_t,   def_prop,       Au_t, symbol, Au_t, u64, u32, u32, ARef) \
    M(AA,BB, s, method, public, Au_t,   def_type,       Au_t, symbol, u64) \
    M(AA,BB, s, method, public, Au_t,   def_member,     Au_t, symbol, Au_t, u32, u64) \
    M(AA,BB, s, method, public, Au_t,   def_class,      Au_t, symbol) \
    M(AA,BB, s, method, public, Au_t,   def_struct,     Au_t, symbol) \
    M(AA,BB, s, method, public, Au_t,   def_func_ptr,   Au_t, symbol) \
    M(AA,BB, s, method, public, Au_t,   def_pointer,    Au_t, Au_t, symbol) \
    M(AA,BB, s, method, public, Au_t,   def_enum,       Au_t, symbol, u64) \
    M(AA,BB, s, method, public, Au_t,   def_enum_value, Au_t, symbol, Au) \
    M(AA,BB, s, method, public, Au,     parse,          Au_t, cstr, ctx) \
    M(AA,BB, s, method, public, Au_t,   find_member,    Au_t, symbol, i32, bool) \
    M(AA,BB, s, method, public, Au_t,   find_context,   array, i32, i32) \
    M(AA,BB, s, method, public, Au_t,   lexical,        array, symbol) \
    M(AA,BB, i, method, public, Au,     initialize) \
    M(AA,BB, s, method, public, Au_t,   module_lookup,  symbol) \
    M(AA,BB, s, method, public, Au_t,   def_module,     symbol) \
    M(AA,BB, s, method, public, Au_t,   global) \
    M(AA,BB, s, method, public, Au_t,   scope_lookup,   array, string) \
    M(AA,BB, s, method, public, Au_t,   current_module) \
    M(AA,BB, i, method, public, Au,     member_object,  Au_t) \
    M(AA,BB, i, method, public, bool,   member_set, Au_t, Au) \
    M(AA,BB, s, method, public, Au,     header, Au) \
    M(AA,BB, i, method, public, Au,     vdata) \
    M(AA,BB, i, method, public, Au_t,   vdata_type) \
    M(AA,BB, i, method, public, i64,    vdata_stride) \
    M(AA,BB, i, method, public, bool,   is_meta) \
    M(AA,BB, i, method, public, bool,   is_meta_compatible, Au) \
    M(AA,BB, s, vargs,  public, Au,     formatter, Au_t, handle, Au, symbol) \
    M(AA,BB, s, method, public, Au,     alloc, Au_t, num, Au_ts) \
    M(AA,BB, s, method, public, Au,     alloc_new, Au_t, num, Au_ts) \
    M(AA,BB, s, method, public, Au,     alloc_dbg, Au_t, num, cstr, i32) \
    M(AA,BB, s, method, public, Au,     alloc2, Au_t, Au_t, shape) \
    M(AA,BB, s, method, public, string, estring, Au_t, i32) \
    M(AA,BB, s, method, public, i32,    evalue, Au_t, cstr) \
    M(AA,BB, s, method, public, none,   serialize, Au_t, string, Au) \
    M(AA,BB, s, method, public, Au,     convert, Au_t, Au) \
    M(AA,BB, s, method, public, bool,   inherits, Au_t, Au_t) \
    M(AA,BB, s, method, public, Au, construct_with, Au_t, Au, ctx) \
    M(AA,BB, s, method, public, bool, constructs_with, Au_t, Au_t) \
    M(AA,BB, s, method, public, Au_t, find_ctr, Au_t, Au_t, bool) \
    M(AA,BB, s, method, public, Au_t, member_first, Au_t, Au_t, bool) \
    M(AA,BB, s, method, public, Au, primitive, Au_t, raw) \
    M(AA,BB, s, method, public, Au, method, Au_t, cstr, array) \
    M(AA,BB, s, method, public, i32, alloc_count, Au_t) \
    M(AA,BB, s, method, public, none, push_type, Au_t) \
    M(AA,BB, s, method, public, Au,   typecast, Au_t, Au) \
    M(AA,BB, s, method, public, none, dealloc_type, Au_t) \
    M(AA,BB, s, method, public, none, member_override, Au_t, Au_t, AFlag) \
    M(AA,BB, s, method, public, none, def_init, func) \
    M(AA,BB, s, method, public, bool, is_inlay, Au_t) \
    M(AA,BB, s, method, public, Au_t, find_module, symbol) \
    M(AA,BB, s, method, public, Au_t, find_type, symbol, Au_t) \
    M(AA,BB, s, method, public, map, arguments, i32, cstrs, map, Au) \
    M(AA,BB, s, method, public, ARef, types, ref_i64) \
    M(AA,BB, s, method, public, none, tap, symbol, hook) \
    M(AA,BB, s, method, public, none, untap, symbol) \
    M(AA,BB, s, method, public, none, recycle) \
    M(AA,BB, s, method, public, none, engage, cstrs) \
    M(AA,BB, s, vargs, public, map, args, cstrs, symbol) \
    M(AA,BB, s, vargs, public, map, map_of, symbol) \
    M(AA,BB, i, guard, public, bool, is_generic,    Au) \
    M(AA,BB, i, guard, public, bool, is_au_type,    Au) \
    M(AA,BB, i, guard, public, bool, is_imported_type, Au) \
    M(AA,BB, i, guard, public, bool, is_integral,   Au) \
    M(AA,BB, i, guard, public, bool, is_void,       Au) \
    M(AA,BB, i, guard, public, bool, is_double,     Au) \
    M(AA,BB, i, guard, public, bool, is_float,      Au) \
    M(AA,BB, i, guard, public, bool, is_realistic,  Au) \
    M(AA,BB, i, guard, public, bool, is_bool,       Au) \
    M(AA,BB, i, guard, public, bool, is_class,      Au) \
    M(AA,BB, i, guard, public, bool, is_struct,     Au) \
    M(AA,BB, i, guard, public, bool, is_opaque,     Au) \
    M(AA,BB, i, guard, public, bool, is_lambda,     Au) \
    M(AA,BB, i, guard, public, bool, is_func,       Au) \
    M(AA,BB, i, guard, public, bool, is_module,     Au) \
    M(AA,BB, i, guard, public, bool, is_func_ptr,   Au) \
    M(AA,BB, i, guard, public, bool, is_imethod,    Au) \
    M(AA,BB, i, guard, public, Au_t, is_rec,        Au) \
    M(AA,BB, i, guard, public, bool, is_prim,       Au) \
    M(AA,BB, i, guard, public, bool, is_sign,       Au) \
    M(AA,BB, i, guard, public, bool, is_unsign,     Au) \
    M(AA,BB, i, guard, public, bool, is_ptr,        Au) \
    M(AA,BB, i, guard, public, bool, is_enum,       Au) \
    M(AA,BB, i, guard, public, bool, is_type,       Au) \
    M(AA,BB, i, ctr,   public, cereal) \
    M(AA,BB, i, ctr,   public, cstrs) \
    M(AA,BB, i, cast,  public, string) \
    M(AA,BB, i, cast,  public, Au_t) \
    M(AA,BB, i, cast,  public, bool)

#define Au_intern_footer(AA)

#define Au_intern(AA,YY,...) Au_schema(AA,YY,__VA_ARGS__)

//typedef struct _shape *shape;
forward(shape)

declare_base(Au)

_Pragma("pack(push, 1)")
typedef struct _Au_t_f {
    Au_f_members(Au)
    struct { void(*_ff)();
        Au_schema (Au, METHOD)
    } ft;
} Au_t_f;

typedef struct Au_t_f_info {
    struct _Au     info;
    Au_t_f         type;
} Au_t_f_info;
_Pragma("pack(pop)")

extern Au_t_f_info Au_t_f_i;

#define typeid(AA)   ((Au_t)&AA##_i.type)
#define scalarof(AA) head(AA)->scalar
#define instanceof(I,A) (A)Au_instance_of((Au)I, typeid(A))

forward(item)

/*
typedef struct _collective_abi {
    i32             count;
    i32             alloc;
    i32             hsize;
    ARef            origin;
    struct _item*   first, *last;
    struct _item*   hlist;
    bool            unmanaged;
    bool            assorted;
    struct _Au_t*   last_type;
} collective_abi;
*/

// these methods could-be var-arg, however not recommended?
#define collective_schema(AA,BB,...) \
    M(AA,BB, i, prop, public, i32,  count) \
    M(AA,BB, i, prop, public, i32,  alloc) \
    M(AA,BB, i, prop, public, i32,  hsize) \
    M(AA,BB, i, origin, public, Au, origin) \
    M(AA,BB, i, prop, public, item, first) \
    M(AA,BB, i, prop, public, item, last) \
    M(AA,BB, i, ref,  public, item, hlist) \
    M(AA,BB, i, prop, public, bool, unmanaged) \
    M(AA,BB, i, prop, public, bool, assorted) \
    M(AA,BB, i, prop, public, Au_t, last_type) \
    M(AA,BB, i, prop, public, Au_t, type) \
    M(AA,BB, i, prop, public, shape, shape) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, method, public, Au, push, Au) \
    M(AA,BB, i, method, public, Au, peek, num) \
    M(AA,BB, i, override, method, len)
declare_class(collective)


// keyword methods, is a simple public method idea to elevate it bracket-less status
// however, the user can define keyword interface, so we can do that.  required is just
// another one of those interfaces that are used in use-case.
#define interface_schema(E,T,Y,...) \
    enum_value       (E,T,Y, undefined,  0) \
    enum_value       (E,T,Y, intern,     1) \
    enum_value       (E,T,Y, public,     2) \
    enum_value       (E,T,Y, guard,      3) \
    enum_value       (E,T,Y, context,    4) \
    enum_value       (E,T,Y, keyword,    5)
declare_enum(interface)

#define comparison_schema(E,T,Y,...) \
    enum_value(E,T,Y, equals,            32) \
    enum_value(E,T,Y, not_equals,        33) \
    enum_value(E,T,Y, u_greater_than,    34) \
    enum_value(E,T,Y, u_greater_than_e,  35) \
    enum_value(E,T,Y, u_less_than,       36) \
    enum_value(E,T,Y, u_less_than_e,     37) \
    enum_value(E,T,Y, s_greater_than,    38) \
    enum_value(E,T,Y, s_greater_than_e,  39) \
    enum_value(E,T,Y, s_less_than,       40) \
    enum_value(E,T,Y, s_less_than_e,     41)
declare_enum(comparison)

//forward(shape)

#define array_schema(AA,BB,O,...) \
    M(AA,BB, i, method,   public, array,  mix,           array, f32) \
    M(AA,BB, i, method,   public, Au,     first_element) \
    M(AA,BB, i, method,   public, Au,     last_element) \
    M(AA,BB, i, method,   public, Au,     pop) \
    M(AA,BB, i, method,   public, array,  shift) \
    M(AA,BB, i, method,   public, Au,     qpush,         Au) \
    M(AA,BB, i, method,   public, string, join,          cstr) \
    M(AA,BB, i, method,   public, none,   fill,          Au) \
    M(AA,BB, i, method,   public, array,  reverse) \
    M(AA,BB, i, method,   public, none,   remove,        num) \
    M(AA,BB, i, method,   public, none,   remove_weak,   num) \
    M(AA,BB, i, method,   public, none,   push_vdata,    Au, i64, Au_t) \
    M(AA,BB, i, method,   public, none,   push_weak,     Au) \
    M(AA,BB, i, method,   public, none,   clear) \
    M(AA,BB, i, method,   public, none,   concat,        array) \
    M(AA,BB, i, method,   public, Au,     get,           num) \
    M(AA,BB, i, method,   public, num,    count) \
    M(AA,BB, i, method,   public, num,    index_of,      Au) \
    M(AA,BB, s, vargs,    public, array,  array_of,      Au) \
    M(AA,BB, s, vargs,    public, array,  array_of_cstr, cstr) \
    M(AA,BB, i, vargs,    public, none,   push_symbols,  cstr) \
    M(AA,BB, i, vargs,    public, none,   push_objects,  Au) \
    M(AA,BB, i, operator, public, none,  _assign_add,    Au) \
    M(AA,BB, i, operator, public, none,  _assign_sub,    num) \
    M(AA,BB, i, cast,     public, map) \
    M(AA,BB, i, index,    public, Au,     Au) \
    M(AA,BB, i, index,    public, Au,     num) \
    M(AA,BB, i, ctr,      public, i32) \
    M(AA,BB, i, override, method, push) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, override, method, dealloc) \
    M(AA,BB, i, override, cast,   bool) \
    M(AA,BB, i, override, cast,   string)
declare_class_2(array, collective)

#define numeric_schema(AA,BB,...)
declare_abstract(numeric)

#define f64_schema(AA,BB,...) \
    M(AA,BB, i, method, public, f64, round, i32) \
    M(AA,BB, i, method, public, f64, is_nan) \
    M(AA,BB, i, method, public, f64, is_inf) \
    M(AA,BB, i, method, public, f64, is_finite) \
    M(AA,BB, i, method, public, f64, is_zero) \
    M(AA,BB, i, override, cast, string)
declare_primitive(f64, numeric)

#define f32_schema(AA,BB,...) \
    M(AA,BB, i, method, public, f32, round, i32) \
    M(AA,BB, i, method, public, f32, is_nan) \
    M(AA,BB, i, method, public, f32, is_inf) \
    M(AA,BB, i, method, public, f32, is_finite) \
    M(AA,BB, i, method, public, f32, is_zero) \
    M(AA,BB, i, override, cast, string)
declare_primitive(f32, numeric)

#define string_like_schema(X,Y,...)
declare_abstract(string_like)

#define nil_schema(X,Y,...)
declare_abstract(nil)

#define raw_schema(X,Y,...)
declare_abstract(raw)
 
#define ref_schema(X,Y,...)
declare_abstract(ref)

#define imported_schema(X,Y,...)
declare_abstract(imported)

#define ARef_schema(X,Y,...)        ref_schema(X,Y,...)
#define i8_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define i16_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define i32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define i64_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u8_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define u16_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u64_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define fp16_schema(X,Y,...)        numeric_schema(numeric,Y,...)
#define bf16_schema(X,Y,...)        numeric_schema(numeric,Y,...)
//#define f32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
//#define f64_schema(X,Y,...)         numeric_schema(numeric,Y,...)

#define fmt(...) ((string)f(string, __VA_ARGS__))

#define ref_i8_schema(X,Y,...)      numeric_schema(numeric,Y,...)
#define ref_i16_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_i32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_i64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u8_schema(X,Y,...)      numeric_schema(numeric,Y,...)
#define ref_u16_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_f32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_f64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_bool_schema(X,Y,...)    numeric_schema(numeric,Y,...)

#define AFlag_schema(X,Y,...)       numeric_schema(numeric,Y,...)
#define bool_schema(X,Y,...)        numeric_schema(numeric,Y,...)
#define num_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define sz_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define cstr_schema(X,Y,...)        string_like_schema(X,Y,...)
#define symbol_schema(X,Y,...)      string_like_schema(X,Y,...)
#define cereal_schema(X,Y,...)      raw_schema(X,Y,...)
#define none_schema(X,Y,...)        nil_schema(X,Y,...)
#define raw_t_schema(X,Y,...)       raw_schema(X,Y,...)
#define handle_schema(X,Y,...)      raw_schema(X,Y,...)
#define Au_t_schema(X,Y,...)       raw_schema(X,Y,...)
#define func_schema(X,Y,...)        raw_schema(X,Y,...)
#define hook_schema(X,Y,...)        raw_schema(X,Y,...)
#define callback_schema(X,Y,...)    raw_schema(X,Y,...)
#define callback_extra_schema(X,Y,...)    raw_schema(X,Y,...)
#define cstrs_schema(X,Y,...)       raw_schema(X,Y,...)
#define Au_ts_schema(X,Y,...)      raw_schema(X,Y,...)
#define floats_schema(X,Y,...)      raw_schema(X,Y,...)

/// meta gives us access to one token we can override with (F)

static inline bool AF_get(u64* f, u32 bit_index) {
    if (bit_index < 64) {
        return (f[0] & (((u64)1) << bit_index)) != 0;
    } else {
        return (f[1] & (((u64)1) << (bit_index - 64))) != 0;
    }
}

#define AF_set(f, bit_index) ({ \
    if (bit_index < 64) { \
        ((u64*)f)[0] |= ((u64)1) << bit_index; \
    } else { \
        ((u64*)f)[1] |= ((u64)1) << (bit_index - 64); \
    } \
})

/*
static inline void AF_set(u64* f, u32 bit_index) {
    if (bit_index < 64) {
        f[0] |= ((u64)1) << bit_index;
    } else {
        f[1] |= ((u64)1) << (bit_index - 64);
    }
}
*/

declare_primitive(ref_i8,           numeric)
declare_primitive(ref_i16,          numeric)
declare_primitive(ref_i32,          numeric)
declare_primitive(ref_i64,          numeric)
declare_primitive(ref_u8,           numeric)
declare_primitive(ref_u16,          numeric)
declare_primitive(ref_u32,          numeric)
declare_primitive(ref_u64,          numeric)
declare_primitive(ref_f32,          numeric)
declare_primitive(ref_f64,          numeric)
declare_primitive(ref_bool,         numeric)

declare_primitive( i8,              numeric)
declare_primitive(i16,              numeric)
declare_primitive(i32,              numeric)
declare_primitive(i64,              numeric)
declare_primitive( u8,              numeric)
declare_primitive(u16,              numeric)
declare_primitive(u32,              numeric)
declare_primitive(u64,              numeric)
declare_primitive(fp16,             numeric)
declare_primitive(bf16,             numeric)
//declare_primitive(f32,              numeric)
//declare_primitive(f64,              numeric)

//declare_primitive(f32, numeric)
//declare_primitive(f64, numeric)

declare_primitive(AFlag,            numeric)
declare_primitive(bool,             numeric)
declare_primitive(num,              numeric)
declare_primitive(sz,               numeric)
declare_primitive(cstr,             string_like)
declare_primitive(symbol,           string_like)
declare_primitive(none,             nil)
declare_primitive(cereal,           raw)
declare_primitive(raw_t,            raw)
declare_primitive(handle,           raw)
declare_primitive(func,             raw)
declare_primitive(hook,             raw)
declare_primitive(callback,         raw)
declare_primitive(callback_extra,   raw)
declare_primitive(cstrs,            raw)
declare_primitive(Au_ts,           raw)

/// whatever we can 'name', we can handle as a type of any pointer primitive
//declare_primitive(Au_t,        raw)
declare_primitive(ARef,         ref)
declare_primitive(floats,       raw)

/// lets mimmick the structure in llama.cpp
#define msg_schema(AA,BB,...) \
    M(AA,BB, i, prop, public, cstr, role) \
    M(AA,BB, i, prop, public, cstr, content) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, override, method, dealloc)
declare_class(msg)


#undef shape

forward(shape)

#ifndef __cplusplus
#define shape_schema(AA,BB,...) \
    M(AA,BB, i, prop,    public, i64,  count) \
    M(AA,BB, i, ref,     public, i64,  data) \
    M(AA,BB, i, prop,    public, bool, is_global) \
    M(AA,BB, i, prop,    public, bool, explicit) \
    M(AA,BB, i, method,  public, shape, with_array, array) \
    M(AA,BB, i, method,  public, i64,   total) \
    M(AA,BB, i, method,  public, none,  push, i64) \
    M(AA,BB, s, method,  public, shape, shape_from, i64, ref_i64) \
    M(AA,BB, s, method,  public, shape, shape_read, ARef) \
    M(AA,BB, s, vargs,   public, shape, new_shape, i64) \
    M(AA,BB, i, override, method, compare) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, override, method, dealloc)
declare_class(shape)
#else
// shape mysteriously defined in cpp somewhere else
ARef new_shape(i64, ...);
#endif


/// doubly-linked item type, integrated key so we dont also need a 'field' type
#define item_schema(AA,BB,...) \
    M(AA,BB, i, prop,     opaque, AA,  next) \
    M(AA,BB, i, prop,     opaque, AA,  prev) \
    M(AA,BB, i, prop,     opaque, Au,  ref)  \
    M(AA,BB, i, prop,     opaque, Au,  value) \
    M(AA,BB, i, prop,     opaque, Au,  key) \
    M(AA,BB, i, prop,     opaque, u64, h) \
    M(AA,BB, i, override, method, hash) \
    M(AA,BB, i, override, method, init)
declare_class(item)

/// linked-list of elemental data
#define list_schema(AA,BB,...) \
    M(AA,BB, i, method, public, Au,   pop) \
    M(AA,BB, i, override, method, push) \
    M(AA,BB, i, method, public, none, push_item, item) \
    M(AA,BB, i, method, public, item, insert_after, Au, i32) \
    M(AA,BB, i, method, public, num,  index_of, Au) \
    M(AA,BB, i, method, public, item, item_of, Au) \
    M(AA,BB, i, method, public, none, sort, ARef) \
    M(AA,BB, i, method, public, none, remove, num) \
    M(AA,BB, i, method, public, none, remove_item, item) \
    M(AA,BB, i, method, public, Au,   value_by_index, Au) \
    M(AA,BB, i, method, public, num,  count) \
    M(AA,BB, i, override, method, dealloc)
declare_class_2(list, collective)

/// array of elemental data
/// important to define the same operators here in silver definition of runtime
/// one has arguments (operator) and (cast) does not, thats always instance
/// we need different names for these.  they cannot both be considered 'operators'
/// we also need new data structure, so ops vs casts vs constructs vs methods
// += -= *= /= 
// ":", "+=", "-=", "*=", "/=", "|=",
// "&=", "^=", ">>=", "<<=", "%=", null);
/*

static struct op_entry op_table[] = {
    { LLVMBuildAdd },
    { LLVMBuildSub }, 
    { LLVMBuildMul }, 
    { LLVMBuildSDiv }, 
    { LLVMBuildOr }, 
    { LLVMBuildAnd },
    { LLVMBuildOr }, 
    { LLVMBuildAnd },
    { LLVMBuildXor },  
    { LLVMBuildURem },
    { LLVMBuildAShr },
    { LLVMBuildShl }
};
*/

#define OPType_schema(E,T,Y,...) \
    enum_value(E,T,Y, _undefined,         0) \
    enum_value(E,T,Y, _add,               1) \
    enum_value(E,T,Y, _sub,               2) \
    enum_value(E,T,Y, _mul,               3) \
    enum_value(E,T,Y, _div,               4) \
    enum_value(E,T,Y, _or,                5) \
    enum_value(E,T,Y, _and,               6) \
    enum_value(E,T,Y, _bitwise_or,        7) \
    enum_value(E,T,Y, _bitwise_and,       8) \
    enum_value(E,T,Y, _xor,               9) \
    enum_value(E,T,Y, _mod,               10) \
    enum_value(E,T,Y, _right,             11) \
    enum_value(E,T,Y, _left,              12) \
    enum_value(E,T,Y, _compare,           13) \
    enum_value(E,T,Y, _equal,             14) \
    enum_value(E,T,Y, _not_equal,         15) \
    enum_value(E,T,Y, _greater,           16) \
    enum_value(E,T,Y, _less,              17) \
    enum_value(E,T,Y, _greater_eq,        18) \
    enum_value(E,T,Y, _less_eq,           19) \
    enum_value(E,T,Y, _is,                20) \
    enum_value(E,T,Y, _inherits,          21) \
    enum_value(E,T,Y, _value_default,     22) \
    enum_value(E,T,Y, _cond_value,        23) \
    enum_value(E,T,Y, _assign,            24) \
    enum_value(E,T,Y, _assign_add,        25) \
    enum_value(E,T,Y, _assign_sub,        26) \
    enum_value(E,T,Y, _assign_mul,        27) \
    enum_value(E,T,Y, _assign_div,        28) \
    enum_value(E,T,Y, _assign_or,         29) \
    enum_value(E,T,Y, _assign_and,        30) \
    enum_value(E,T,Y, _assign_xor,        31) \
    enum_value(E,T,Y, _assign_mod,        32) \
    enum_value(E,T,Y, _assign_right,      33) \
    enum_value(E,T,Y, _assign_left,       34)
declare_enum(OPType)

#define Key_schema(EE,TT,YY) \
    enum_value_v(EE, TT, YY, Undefined,      0) \
    enum_value_v(EE, TT, YY, Space,         32) \
    enum_value_v(EE, TT, YY, Apostrophe,    39) \
    enum_value_v(EE, TT, YY, Comma,         44) \
    enum_value_v(EE, TT, YY, Minus,         45) \
    enum_value_v(EE, TT, YY, Period,        46) \
    enum_value_v(EE, TT, YY, Slash,         47) \
    enum_value_v(EE, TT, YY, K0,            48) \
    enum_value_v(EE, TT, YY, K1,            49) \
    enum_value_v(EE, TT, YY, K2,            50) \
    enum_value_v(EE, TT, YY, K3,            51) \
    enum_value_v(EE, TT, YY, K4,            52) \
    enum_value_v(EE, TT, YY, K5,            53) \
    enum_value_v(EE, TT, YY, K6,            54) \
    enum_value_v(EE, TT, YY, K7,            55) \
    enum_value_v(EE, TT, YY, K8,            56) \
    enum_value_v(EE, TT, YY, K9,            57) \
    enum_value_v(EE, TT, YY, SemiColon,     59) \
    enum_value_v(EE, TT, YY, Equal,         61) \
    enum_value_v(EE, TT, YY, A,             65) \
    enum_value_v(EE, TT, YY, B,             66) \
    enum_value_v(EE, TT, YY, C,             67) \
    enum_value_v(EE, TT, YY, D,             68) \
    enum_value_v(EE, TT, YY, E,             69) \
    enum_value_v(EE, TT, YY, F,             70) \
    enum_value_v(EE, TT, YY, G,             71) \
    enum_value_v(EE, TT, YY, H,             72) \
    enum_value_v(EE, TT, YY, I,             73) \
    enum_value_v(EE, TT, YY, J,             74) \
    enum_value_v(EE, TT, YY, K,             75) \
    enum_value_v(EE, TT, YY, L,             76) \
    enum_value_v(EE, TT, YY, M,             77) \
    enum_value_v(EE, TT, YY, N,             78) \
    enum_value_v(EE, TT, YY, O,             79) \
    enum_value_v(EE, TT, YY, P,             80) \
    enum_value_v(EE, TT, YY, Q,             81) \
    enum_value_v(EE, TT, YY, R,             82) \
    enum_value_v(EE, TT, YY, S,             83) \
    enum_value_v(EE, TT, YY, T,             84) \
    enum_value_v(EE, TT, YY, U,             85) \
    enum_value_v(EE, TT, YY, V,             86) \
    enum_value_v(EE, TT, YY, W,             87) \
    enum_value_v(EE, TT, YY, X,             88) \
    enum_value_v(EE, TT, YY, Y,             89) \
    enum_value_v(EE, TT, YY, Z,             90) \
    enum_value_v(EE, TT, YY, LeftBracket,   91) \
    enum_value_v(EE, TT, YY, BackSlash,     92) \
    enum_value_v(EE, TT, YY, RightBracket,  93) \
    enum_value_v(EE, TT, YY, GraveAccent,   96) \
    enum_value_v(EE, TT, YY, World1,       161) \
    enum_value_v(EE, TT, YY, World2,       162) \
    enum_value_v(EE, TT, YY, Escape,       256) \
    enum_value_v(EE, TT, YY, Enter,        257) \
    enum_value_v(EE, TT, YY, Tab,          258) \
    enum_value_v(EE, TT, YY, Backspace,    259) \
    enum_value_v(EE, TT, YY, Insert,       260) \
    enum_value_v(EE, TT, YY, Delete,       261) \
    enum_value_v(EE, TT, YY, Right,        262) \
    enum_value_v(EE, TT, YY, Left,         263) \
    enum_value_v(EE, TT, YY, Down,         264) \
    enum_value_v(EE, TT, YY, Up,           265) \
    enum_value_v(EE, TT, YY, PageUp,       266) \
    enum_value_v(EE, TT, YY, PageDown,     267) \
    enum_value_v(EE, TT, YY, Home,         268) \
    enum_value_v(EE, TT, YY, End,          269) \
    enum_value_v(EE, TT, YY, CapsLock,     280) \
    enum_value_v(EE, TT, YY, ScrollLock,   281) \
    enum_value_v(EE, TT, YY, NumLock,      282) \
    enum_value_v(EE, TT, YY, PrintScreen,  283) \
    enum_value_v(EE, TT, YY, Pause,        284) \
    enum_value_v(EE, TT, YY, F1,           290) \
    enum_value_v(EE, TT, YY, F2,           291) \
    enum_value_v(EE, TT, YY, F3,           292) \
    enum_value_v(EE, TT, YY, F4,           293) \
    enum_value_v(EE, TT, YY, F5,           294) \
    enum_value_v(EE, TT, YY, F6,           295) \
    enum_value_v(EE, TT, YY, F7,           296) \
    enum_value_v(EE, TT, YY, F8,           297) \
    enum_value_v(EE, TT, YY, F9,           298) \
    enum_value_v(EE, TT, YY, F10,          299) \
    enum_value_v(EE, TT, YY, F11,          300) \
    enum_value_v(EE, TT, YY, F12,          301) \
    enum_value_v(EE, TT, YY, F13,          302) \
    enum_value_v(EE, TT, YY, F14,          303) \
    enum_value_v(EE, TT, YY, F15,          304) \
    enum_value_v(EE, TT, YY, F16,          305) \
    enum_value_v(EE, TT, YY, F17,          306) \
    enum_value_v(EE, TT, YY, F18,          307) \
    enum_value_v(EE, TT, YY, F19,          308) \
    enum_value_v(EE, TT, YY, F20,          309) \
    enum_value_v(EE, TT, YY, F21,          310) \
    enum_value_v(EE, TT, YY, F22,          311) \
    enum_value_v(EE, TT, YY, F23,          312) \
    enum_value_v(EE, TT, YY, F24,          313) \
    enum_value_v(EE, TT, YY, F25,          314) \
    enum_value_v(EE, TT, YY, Kp0,          320) \
    enum_value_v(EE, TT, YY, Kp1,          321) \
    enum_value_v(EE, TT, YY, Kp2,          322) \
    enum_value_v(EE, TT, YY, Kp3,          323) \
    enum_value_v(EE, TT, YY, Kp4,          324) \
    enum_value_v(EE, TT, YY, Kp5,          325) \
    enum_value_v(EE, TT, YY, Kp6,          326) \
    enum_value_v(EE, TT, YY, Kp7,          327) \
    enum_value_v(EE, TT, YY, Kp8,          328) \
    enum_value_v(EE, TT, YY, Kp9,          329) \
    enum_value_v(EE, TT, YY, KpDecimal,    330) \
    enum_value_v(EE, TT, YY, KpDivide,     331) \
    enum_value_v(EE, TT, YY, KpMultiply,   332) \
    enum_value_v(EE, TT, YY, KpSubtract,   333) \
    enum_value_v(EE, TT, YY, KpAdd,        334) \
    enum_value_v(EE, TT, YY, KpEnter,      335) \
    enum_value_v(EE, TT, YY, KpEqual,      336) \
    enum_value_v(EE, TT, YY, LeftShift,    340) \
    enum_value_v(EE, TT, YY, LeftControl,  341) \
    enum_value_v(EE, TT, YY, LeftAlt,      342) \
    enum_value_v(EE, TT, YY, LeftSuper,    343) \
    enum_value_v(EE, TT, YY, RightShift,   344) \
    enum_value_v(EE, TT, YY, RightControl, 345) \
    enum_value_v(EE, TT, YY, RightAlt,     346) \
    enum_value_v(EE, TT, YY, RightSuper,   347) \
    enum_value_v(EE, TT, YY, Menu,         348)
declare_enum(Key)

#define Exists_schema(E,T,Y,...) \
    enum_value(E,T,Y, no,     0) \
    enum_value(E,T,Y, file,   1) \
    enum_value(E,T,Y, dir,    2)
declare_enum(Exists)

forward(array)


#define vector_schema(AA,BB,...) \
    M(AA,BB, i, prop,   public, Au,     placeholder2) \
    M(AA,BB, i, method, public, none,   vconcat, ARef, num) \
    M(AA,BB, i, method, public, ARef,   vget, num) \
    M(AA,BB, i, method, public, none,   vset, num, ARef) \
    M(AA,BB, i, method, public, none,   vpush, Au) \
    M(AA,BB, i, method, public, vector, vslice, num, num) \
    M(AA,BB, i, method, public, Au,     resize, sz) \
    M(AA,BB, i, method, public, Au,     reallocate, sz) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, ctr,    public, i32) \
    M(AA,BB, i, ctr,    public, path)
declare_class_2(vector, collective)

none vector_init(vector);

// let us declare our vector with string
// Au, user space is simply the cstring

#define subprocedure_schema(AA,BB,...) \
    M(AA,BB, i, prop,   public,   Au,     target) \
    M(AA,BB, i, prop,   public,   Au,     ctx) \
    M(AA,BB, i, prop,   public,   handle, addr) \
    M(AA,BB, i, method, public,   Au,     invoke, Au)
declare_class(subprocedure)

#define subproc(targ, faddr, context) new(subprocedure, target, (Au)targ, ctx, (Au)context, addr, (handle)faddr) 

typedef Au(*mix_fn)(Au, Au, f32);


#define lambda_schema(AA,BB,O,...) \
    M(AA,BB, i, prop,   public, Au_t,     au) \
    M(AA,BB, i, prop,   public, Au,       target) \
    M(AA,BB, i, prop,   public, Au,       args) \
    M(AA,BB, i, prop,   public, Au,       context) \
    M(AA,BB, i, prop,   public, callback, fn) \
    M(AA,BB, i, method, public, Au, call, Au) \
    M(AA,BB, s, method, public, lambda, lambda_instance, Au_t, callback, Au, Au) \
    M(AA,BB, i, override, cast,   bool)
declare_class(lambda)

Exists resource_exists(Au);

#define srcfile_schema(AA,BB,...) \
    M(AA,BB, i, prop,    public, Au,     obj) \
    M(AA,BB, i, ctr,     public, Au) \
    M(AA,BB, i, override, cast,   string)
declare_class(srcfile)

extern int fault_level;

#define level_schema(E,T,Y,...) \
    enum_value(E,T,Y, information, 0) \
    enum_value(E,T,Y, warn,        1) \
    enum_value(E,T,Y, err,         2)
declare_enum(level)

#define map_schema(AA,BB,...) \
    M(AA,BB, i, guard,  public, none, set,        map, Au, Au) \
    M(AA,BB, i, method, public, Au,   get,        Au) \
    M(AA,BB, i, method, public, Au,   value_by_index, num) \
    M(AA,BB, i, method, public, item, lookup,     Au) \
    M(AA,BB, i, method, public, item, fetch,      Au) \
    M(AA,BB, i, method, public, none, rm,         Au) \
    M(AA,BB, i, method, public, none, rm_item,    item) \
    M(AA,BB, i, method, public, bool, contains,   Au) \
    M(AA,BB, i, method, public, none, concat,     map) \
    M(AA,BB, i, method, public, none, clear) \
    M(AA,BB, i, index,  public, Au,   sz) \
    M(AA,BB, i, index,  public, Au,   Au) \
    M(AA,BB, i, ctr,    public, i32) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, override, method, dealloc) \
    M(AA,BB, i, override, cast,   string) \
    M(AA,BB, i, override, cast,   bool) \
    M(AA,BB, i, override, method, copy)
declare_class_2(map, collective)

#define ctx_schema(AA,BB,...) \
    M(AA,BB, i, prop, intern, Au,   app) \
    M(AA,BB, i, prop, intern, bool, establishing, pad, 32)
declare_class_3(ctx, map, collective)

#define ipart_schema(AA,BB,...) \
    M(AA,BB, i, prop, public, bool,   is_expr) \
    M(AA,BB, i, prop, public, string, content)
declare_class(ipart)

#define string_schema(AA,BB,...) \
    M(AA,BB, i, prop,    public, cstr,   chars) \
    M(AA,BB, i, prop,    public, num,    alloc) \
    M(AA,BB, i, prop,    public, num,    ref_length) \
    M(AA,BB, i, prop,    public, num,    count) \
    M(AA,BB, i, prop,    public, u64,    h) \
    M(AA,BB, i, method,  public, bool,   is_numeric) \
    M(AA,BB, i, method,  public, i32,    first) \
    M(AA,BB, i, method,  public, i32,    last) \
    M(AA,BB, i, method,  public, f64,    real_value) \
    M(AA,BB, i, method,  public, i64,    integer_value) \
    M(AA,BB, i, method,  public, string, ucase) \
    M(AA,BB, i, method,  public, string, lcase) \
    M(AA,BB, i, method,  public, array,  split, symbol) \
    M(AA,BB, i, method,  public, string, escape) \
    M(AA,BB, i, method,  public, num,    index_of, symbol) \
    M(AA,BB, i, method,  public, num,    rindex_of, symbol) \
    M(AA,BB, i, method,  public, none,   append, symbol) \
    M(AA,BB, i, method,  public, none,   append_count, symbol, i32) \
    M(AA,BB, i, method,  public, none,   push, u32) \
    M(AA,BB, i, method,  public, none,   concat, string) \
    M(AA,BB, i, method,  public, string, trim) \
    M(AA,BB, i, method,  public, string, ltrim) \
    M(AA,BB, i, method,  public, string, rtrim) \
    M(AA,BB, i, method,  public, string, mid, num, num) \
    M(AA,BB, i, method,  public, none,   reserve, num) \
    M(AA,BB, i, method,  public, none,   writef, handle, bool) \
    M(AA,BB, i, method,  public, bool,   ends_with, symbol) \
    M(AA,BB, i, method,  public, bool,   starts_with, symbol) \
    M(AA,BB, i, method,  public, num,    cmp, symbol) \
    M(AA,BB, i, method,  public, bool,   eq, symbol) \
    M(AA,BB, i, method,  public, string, interpolate, Au) \
    M(AA,BB, i, method,  public, array,  split_parts) \
    M(AA,BB, i, cast,    public, cstr) \
    M(AA,BB, i, cast,    public, sz) \
    M(AA,BB, i, cast,    public, path) \
    M(AA,BB, i, ctr,     public, symbol) \
    M(AA,BB, i, ctr,     public, cstr) \
    M(AA,BB, i, ctr,     public, i32) \
    M(AA,BB, i, operator, public, none,   _assign_add,  string) \
    M(AA,BB, i, operator, public, string, _add,         string) \
    M(AA,BB, i, index,   public, i32, num) \
    M(AA,BB, i, override, method, len) \
    M(AA,BB, i, override, method, hash) \
    M(AA,BB, i, override, method, compare) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, override, cast,   bool) \
    M(AA,BB, i, override, method, copy)
declare_class(string)


#define const_string_schema(AA,Y,...)
declare_class_2(const_string, string)

#define command_schema(AA,BB,...) \
    M(AA,BB, i, method,  public, i32,    exec) \
    M(AA,BB, i, method,  public, string, run) \
    M(AA,BB, s, method,  public, i64,    last_pid) \
    M(AA,BB, i, override, ctr,    cstr)
declare_class_2(command, string)

#define watch_schema(AA,BB,...) \
    M(AA,BB, i, prop,    public, path,  res) \
    M(AA,BB, i, prop,    public, ARef,  callback) \
    M(AA,BB, i, prop,    public, ARef,  argument) \
    M(AA,BB, i, method,  public, none,  pause) \
    M(AA,BB, i, method,  public, none,  start) \
    M(AA,BB, i, override, method, init)
declare_class(watch)

#define mutex_schema(AA,BB,...) \
    M(AA,BB, i, prop,    public, bool, cond) \
    M(AA,BB, i, method,  public, none, lock) \
    M(AA,BB, i, method,  public, none, unlock) \
    M(AA,BB, i, method,  public, none, cond_wait) \
    M(AA,BB, i, method,  public, none, cond_signal) \
    M(AA,BB, i, method,  public, none, cond_broadcast) \
    M(AA,BB, i, prop,    intern, struct mutex_t*, mtx, as, ARef) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, override, method, dealloc)
declare_class(mutex)

#define async_schema(AA,BB,...) \
    M(AA,BB, i, prop,    public, hook,  work_fn) \
    M(AA,BB, i, prop,    public, array, work) \
    M(AA,BB, i, prop,    intern, mutex, global) \
    M(AA,BB, i, prop,    intern, struct thread_t*, threads, as, ARef) \
    M(AA,BB, i, method,  public, Au,   sync, Au) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, override, method, dealloc)
declare_class(async)

#define token_schema(AA,BB,...) \
    M(AA,BB, i, prop,    public, path,   source) \
    M(AA,BB, i, prop,    public, num,    line) \
    M(AA,BB, i, prop,    public, num,    column) \
    M(AA,BB, i, prop,    public, num,    indent) \
    M(AA,BB, i, prop,    public, Au,     literal) \
    M(AA,BB, i, prop,    public, bool,   cmode) \
    M(AA,BB, i, method,  public, Au_t,   get_type) \
    M(AA,BB, i, method,  public, string, location) \
    M(AA,BB, i, method,  public, Au, get_literal, Au_t) \
    M(AA,BB, i, override, ctr,    cstr) \
    M(AA,BB, i, override, method, init) \
    M(AA,BB, i, override, method, copy)
declare_class_2(token, string)

#define tokens_schema(AA,BB,...) \
    M(AA,BB, i, prop,    required, callback_extra, parser) \
    M(AA,BB, i, prop,    required, Au,   target) \
    M(AA,BB, i, prop,    required, Au,   input) \
    M(AA,BB, i, ctr,     public,   cstr) \
    M(AA,BB, i, override, method,  init)
declare_class_3(tokens, array, collective)

#define path_schema(AA,BB,...) \
    M(AA,BB, i, method,  public, bool,   exists) \
    M(AA,BB, i, method,  public, bool,   touch) \
    M(AA,BB, i, method,  public, bool,   create_symlink, path) \
    M(AA,BB, i, method,  public, bool,   is_symlink) \
    M(AA,BB, i, method,  public, path,   resolve) \
    M(AA,BB, i, method,  public, path,   normalize) \
    M(AA,BB, i, method,  public, bool,   make_dir) \
    M(AA,BB, i, method,  public, bool,   remove_dir) \
    M(AA,BB, i, method,  public, bool,   is_ext, symbol) \
    M(AA,BB, i, method,  public, bool,   is_empty) \
    M(AA,BB, i, method,  public, bool,   is_dir) \
    M(AA,BB, i, method,  public, none,   cp, path, bool, bool) \
    M(AA,BB, i, method,  public, path,   directory) \
    M(AA,BB, i, method,  public, none,   cd) \
    M(AA,BB, i, method,  public, string, stem) \
    M(AA,BB, i, method,  public, string, ext) \
    M(AA,BB, i, method,  public, string, mime) \
    M(AA,BB, i, method,  public, string, base64) \
    M(AA,BB, i, method,  public, string, filename) \
    M(AA,BB, i, method,  public, path,   absolute) \
    M(AA,BB, i, method,  public, path,   parent_dir) \
    M(AA,BB, i, method,  public, Au,     load, Au_t, ctx) \
    M(AA,BB, i, method,  public, bool,   save, Au, ctx) \
    M(AA,BB, i, method,  public, path,   change_ext, cstr) \
    M(AA,BB, i, method,  public, array,  ls, string, bool) \
    M(AA,BB, i, method,  public, bool,   move, path) \
    M(AA,BB, i, method,  public, path,   latest_modified, ARef) \
    M(AA,BB, i, method,  public, i64,    modified_time) \
    M(AA,BB, i, method,  public, i64,    wait_for_change, i64, i64) \
    M(AA,BB, s, method,  public, path,   path_self) \
    M(AA,BB, s, method,  public, path,   path_share_path) \
    M(AA,BB, s, method,  public, path,   path_cwd) \
    M(AA,BB, s, method,  public, path,   path_tempfile, symbol) \
    M(AA,BB, i, ctr,     public, string) \
    M(AA,BB, i, ctr,     public, tokens) \
    M(AA,BB, i, override, method,   hash) \
    M(AA,BB, i, override, method,   init) \
    M(AA,BB, i, override, method,   eq) \
    M(AA,BB, i, override, ctr,      symbol) \
    M(AA,BB, i, override, ctr,      cstr) \
    M(AA,BB, i, override, cast,     cstr) \
    M(AA,BB, i, override, cast,     sz) \
    M(AA,BB, i, override, cast,     bool) \
    M(AA,BB, i, override, cast,     string)
declare_class_2(path, string)

#define subscriber_schema(AA,BB,...) \
    M(AA,BB, i, prop, required, Au,       target) \
    M(AA,BB, i, prop, required, callback, method)
declare_class(subscriber)

#define subs_schema(AA,BB,...) \
    M(AA,BB, i, prop,   public, array, entries, meta, subscriber) \
    M(AA,BB, i, method, public, none,  add, Au, callback) \
    M(AA,BB, i, method, public, Au,    invoke, Au)
declare_class(subs)


#define line_schema(AA,BB,...) \
    M(AA,BB, i, prop, public, i32,   indent) \
    M(AA,BB, i, prop, public, array, text)
declare_class(line)

#define app_schema(X,Y,...) \
    M(X,Y,i,method,public,i32,run)
declare_class(app)

#define aclass2_schema(AA,BB,...)
declare_class_2(aclass2, app)

extern FILE* logger;

cstr copy_cstr(cstr input);

/// useful utility for smooth movement of any variable in a variable-step-rate
/// used in Hyper Race 'physics' to make adjustments to cars at varying-frame-rates
static inline f32 filter_n(f32 current, f32 goal, f32 amount, f32 rate) {
    f32 decay = powf(1.0f - amount, rate);
    if (goal != 0.0f)
        return current + ((goal - current) * (1.0f - decay));
    else
        return current * decay;
}

Au      _i8(i8);
Au      _u8(u8);
Au      _i16(i16);
Au      _u16(u16);
Au      _i32(i32);
Au      _u32(u32);
Au      _i64(i64);
Au          i(i64);
Au      _sz(sz);
Au      _u64(u64);
Au      _f32(f32);
Au      _f64(f64);
Au      _fp16(fp16*);
Au      _bf16(bf16*);
Au  float32(f32);
Au   real64(f64);
Au      _cstr(cstr);
Au      _none();
Au      _bool(bool);

string json(Au a);

//#define array_string_schema(X,Y,...)
//declare_class_2(array_string,     array, string)

//#define array_map_schema(X,Y,...)
//declare_class_2(array_map,        array, map)

static inline f32 f32_mix(f32 a, f32 b, f32 f) {
    return a * (1.0f - f) + b * f;
}

/// use i_struct_ctr_obj for objects or primitives
/// use i_struct_ctr for structs.. this is because we cannot separate * from the token
#define vec_methods(O, Y, T, ...) \
    i_struct_ctr_obj(O,Y, floats) \
    i_struct_method(O, Y, T,    length) \
    i_struct_method(O, Y, O,    add,      O*) \
    i_struct_method(O, Y, O,    sub,      O*) \
    i_struct_method(O, Y, O,    mul,      O*) \
    i_struct_method(O, Y, O,    scale,    f32) \
    i_struct_method(O, Y, T,    dot,      O*) \
    i_struct_method(O, Y, O,    normalize) \
    i_struct_method(O, Y, O,    mix,      O*, f64) \
    i_struct_cast  (O, Y, string)

#define rgb8_schema(O, Y, ...) \
    i_struct_prop(O,Y,u8, r) \
    i_struct_prop(O,Y,u8, g) \
    i_struct_prop(O,Y,u8, b)
declare_struct(rgb8)

#define rgbf_schema(O, Y, ...) \
    i_struct_prop(O,Y, f32, r) \
    i_struct_prop(O,Y, f32, g) \
    i_struct_prop(O,Y, f32, b)
declare_struct(rgbf)

#define rgba8_schema(O, Y, ...) \
    i_struct_prop(O,Y,u8, r) \
    i_struct_prop(O,Y,u8, g) \
    i_struct_prop(O,Y,u8, b) \
    i_struct_prop(O,Y,u8, a)
declare_struct(rgba8)

#define rgba16_schema(O, Y, ...) \
    i_struct_prop(O,Y,u16, r) \
    i_struct_prop(O,Y,u16, g) \
    i_struct_prop(O,Y,u16, b) \
    i_struct_prop(O,Y,u16, a)
declare_struct(rgba16)

typedef struct _vec3f vec3f;

#define vec4f_schema(O, Y, T, ...) \
    i_struct_ctr(O,Y, vec3f) \
    i_struct_prop  (O, Y, T, x) \
    i_struct_prop  (O, Y, T, y) \
    i_struct_prop  (O, Y, T, z) \
    i_struct_prop  (O, Y, T, w) \
    vec_methods(O, Y, T, __VA_ARGS__)
declare_struct(vec4f, f32)

#define rgbaf_schema(O, Y, ...) \
    i_struct_ctr(O,Y, vec4f) \
    i_struct_prop(O,Y, f32, r) \
    i_struct_prop(O,Y, f32, g) \
    i_struct_prop(O,Y, f32, b) \
    i_struct_prop(O,Y, f32, a)
declare_struct(rgbaf)

#define vec3f_schema(O, Y, T, ...) \
    i_struct_prop  (O, Y, T, x) \
    i_struct_prop  (O, Y, T, y) \
    i_struct_prop  (O, Y, T, z) \
    i_struct_method(O, Y, O, cross, O*) \
    i_struct_static(O, Y, O, rand) \
    vec_methods(O, Y, T)
declare_struct(vec3f, f32)

#define quatf_schema(O, Y, ...) \
    i_struct_ctr(O,Y, vec4f) \
    i_struct_prop(O,Y,f32, x) \
    i_struct_prop(O,Y,f32, y) \
    i_struct_prop(O,Y,f32, z) \
    i_struct_prop(O,Y,f32, w)
declare_struct(quatf)

#define rgba_schema(AA,BB,...) \
    M(AA,BB, i, prop,   public, f32,   r) \
    M(AA,BB, i, prop,   public, f32,   g) \
    M(AA,BB, i, prop,   public, f32,   b) \
    M(AA,BB, i, prop,   public, f32,   a) \
    M(AA,BB, i, method, public, rgba,  mix, rgba, f32) \
    M(AA,BB, i, ctr,    public, cstr) \
    M(AA,BB, i, ctr,    public, string)
declare_class(rgba)


f32 degrees(f32 rads);
f32 radians(f32 degs);


#define vec2f_schema(O, Y, T, ...) \
    i_struct_prop (O, Y, T, x) \
    i_struct_prop (O, Y, T, y) \
    vec_methods   (O, Y, T, __VA_ARGS__)
declare_struct(vec2f, f32)

#define rect_schema(O, Y, ...) \
    i_prop (O, Y, public, f32, x) \
    i_prop (O, Y, public, f32, y) \
    i_prop (O, Y, public, f32, w) \
    i_prop (O, Y, public, f32, h) \
    i_method(O, Y, public, vec2f, xy) \
    s_method(O, Y, public, rect, create_rect, vec2f, vec2f)
declare_class(rect)

#define mat4f_schema(O, Y, T, ...) \
    i_struct_array  (O, Y, f32,   16, m) \
    i_struct_ctr_obj(O, Y, floats) \
    i_struct_ctr    (O, Y, quatf) \
    i_struct_method (O, Y, O,        inverse) \
    i_struct_method (O, Y, O,        transpose) \
    i_struct_static (O, Y, O,        identity) \
    i_struct_static (O, Y, O,        perspective, f32, f32, f32, f32) \
    i_struct_static (O, Y, O,        ortho,      f32, f32, f32, f32, f32, f32) \
    i_struct_static (O, Y, O,        look_at,    vec3f*, vec3f*, vec3f*) \
    i_struct_method (O, Y, O,        scale,      vec3f*) \
    i_struct_method (O, Y, O,        translate,  vec3f*) \
    i_struct_method (O, Y, O,        rotate,     quatf*) \
    i_struct_method (O, Y, vec4f,    mul_v4,     vec4f*) \
    i_struct_method (O, Y, none,     set_identity) \
    i_struct_method (O, Y, O,        mul,        O*) \
    i_struct_cast   (O, Y, string)
declare_struct(mat4f, f32)


// will need to adjust json serialization to facilitate vector with meta types
#define vector_mat4f_schema(X,Y,...)
declare_class_3(vector_mat4f, vector, collective, mat4f)

#define vector_vec4f_schema(X,Y,...)
declare_class_3(vector_vec4f, vector, collective, vec4f)

#define vector_vec3f_schema(X,Y,...)
declare_class_3(vector_vec3f, vector, collective, vec3f)

#define vector_vec2f_schema(X,Y,...)
declare_class_3(vector_vec2f, vector, collective, vec2f)

#define vector_i8_schema(X,Y,...)
declare_class_3(vector_i8, vector, collective, i8)

#define vector_f32_schema(X,Y,...)
declare_class_3(vector_f32, vector, collective, f32)

#define vector_f64_schema(X,Y,...)
declare_class_3(vector_f64, vector, collective, f64)

#define vector_i64_schema(X,Y,...)
declare_class_3(vector_i64, vector, collective, i64)

#define vector_rgba8_schema(X,Y,...)
declare_class_3(vector_rgba8, vector, collective, rgba8)

#define vector_rgba16_schema(X,Y,...)
declare_class_3(vector_rgba16, vector, collective, rgba16)

#define vector_rgbaf_schema(X,Y,...)
declare_class_3(vector_rgbaf, vector, collective, rgbaf)

#define vector_rgb8_schema(X,Y,...)
declare_class_3(vector_rgb8, vector, collective, rgb8)

#define vector_rgbf_schema(X,Y,...)
declare_class_3(vector_rgbf, vector, collective, rgbf)



vector_f32   vector_f32_new  (shape count, ...);
vector_f64   vector_f64_new  (shape count, ...);
vector_i8    vector_i8_new   (shape count, ...);
vector_i64   vector_i64_new  (shape count, ...);
vector_rgba16 vector_rgba16_new(shape count, ...);
vector_rgba8 vector_rgba8_new(shape count, ...);
vector_rgbaf vector_rgbaf_new(shape count, ...);
vector_rgb8  vector_rgb8_new (shape count, ...);
vector_rgbf  vector_rgbf_new (shape count, ...);


cstr cstr_copy(cstr f);

none set_meta_array(Au_t type, int count, ...);
none set_args_array(Au_t type, int count, ...);
none set_meta_map(Au_t type, int count, ...);

none array_init(array);

Au_t au_arg(Au a);
Au_t au_arg_type(Au a);

#define weak_schema(X,Y,...)
declare_abstract(weak)

#define functional_schema(X,Y,...)
declare_abstract(functional)

#define cast(T,I) fcall(I, cast_##T)

none halt(string);

#ifdef __cplusplus
}
#endif

#endif