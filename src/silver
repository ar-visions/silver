#ifndef _silver_
#define _silver_

#define silver_schema(X, Y, ...)                     \
    M(X, Y, i, prop, public, bool, build)            \
    M(X, Y, i, prop, public, i32, expr_level)        \
    M(X, Y, i, prop, public, i32, parens_depth)      \
    M(X, Y, i, prop, public, string, git_service)    \
    M(X, Y, i, prop, public, string, git_owner)      \
    M(X, Y, i, prop, public, string, git_project)    \
    M(X, Y, i, prop, public, string, source_raw)     \
    M(X, Y, i, prop, public, path, src_loc)          \
    M(X, Y, i, prop, intern, array, implements)      \
    M(X, Y, i, prop, intern, array, imports)         \
    M(X, Y, i, prop, intern, bool, read_etype_abort) \
    M(X, Y, i, prop, public, etype, last_return)     \
    M(X, Y, i, prop, public, bool, left_hand)        \
    M(X, Y, i, prop, public, map, codegens)          \
    M(X, Y, i, method, public, none, write_header)   \
    M(X, Y, i, prop, intern, map, import_cache) \
    M(X, Y, i, prop, intern, map, instances) \
    M(X, Y, i, method, public,     enode,          parse_member_expr, enode) \
    M(X, Y, i, method, public,     none,           incremental_resolve) \
    M(X, Y, i, method, public,     token,          next) \
    M(X, Y, i, method, public,     token,          prev) \
    M(X, Y, i, method, public,     token,          navigate, i32) \
    M(X, Y, i, method, public,     token,          consume) \
    M(X, Y, i, method, public,     token,          peek) \
    M(X, Y, i, method, public,     token,          element, num) \
    M(X, Y, i, method, public,     num,            current_line) \
    M(X, Y, i, method, public,     bool,           next_is_alpha) \
    M(X, Y, i, method, public,     bool,           next_indent) \
    M(X, Y, i, method, public,     enode,          read_enode, etype) \
    M(X, Y, i, method, public,     enode,          parse_ternary, enode, etype) \
    M(X, Y, i, method, public,     enode,          parse_assignment, enode, string) \
    M(X, Y, i, method, public,     token,          read_if, symbol) \
    M(X, Y, i, method, public,     Au,              read_literal, Au_t) \
    M(X, Y, i, method, public,     string,         read_string) \
    M(X, Y, i, method, public,     string,         read_alpha) \
    M(X, Y, i, method, public,     string,         read_alpha_any) \
    M(X, Y, i, method, public,     string,         peek_alpha) \
    M(X, Y, i, method, public,     bool,           next_is_neighbor) \
    M(X, Y, i, method, public,     etype,          read_def) \
    M(X, Y, i, method, public,     string,         peek_def) \
    M(X, Y, i, method, public,     string,         peek_keyword) \
    M(X, Y, i, method, public,     string,         read_keyword) \
    M(X, Y, i, method, public,     Au,              read_bool) \
    M(X, Y, i, method, public,     Au,              read_numeric) \
    M(X, Y, i, method, public,     array,          parse_const, array) \
    M(X, Y, i, method, public,     string,         read_assign, ARef, ARef) \
    M(X, Y, i, method, public,     string,         location) \
    M(X, Y, i, method, public,     none,           parse) \
    M(X, Y, i, method, public,     none,           build) \
    M(X, Y, i, ctr,    public,     path) \
    M(X, Y, i, override, method, init)
declare_class_3(silver, aether, etype)

#define import_schema(X, Y, ...)                    \
    M(X, Y, i, prop,  public, codegen, codegen)     \
    M(X, Y, i, prop,  public, silver, external)     \
    M(X, Y, i, prop,  public, array, tokens)        \
    M(X, Y, i, prop,  public, array, module_paths)  \
    M(X, Y, i, prop,  public, array, include_paths) \
    M(X, Y, s, method,public, enode, parse, silver)
declare_class_2(import, etype)

#define chatgpt_schema(X, Y, ...) \
    M(X, Y, i, override, method, generate_fn)
declare_class_2(chatgpt, codegen)

/*

#define build_state_schema(E,T,Y,...) \
    enum_value(E,T,Y, none,       0) \
    enum_value(E,T,Y, built,      1)
declare_enum(build_state)

#define language_schema(E,T,Y,...) \
    enum_value(E,T,Y, silver, 0)
declare_enum(language)

#define completer_context_schema(X,Y,...) \
    i_prop(X,Y, required, model,    data) \
    i_prop(X,Y, required, array,    body)
declare_class(completer_context)

forward(import)

#define silver_schema(X,Y,...)\
    i_prop    (X,Y, intern,     import,         import) \
    i_prop    (X,Y, intern,     array,          implements) \
    i_prop    (X,Y, intern,     bool,           in_const) \
    i_prop    (X,Y, intern,     bool,           in_left) \
    i_prop    (X,Y, intern,     bool,           in_inlay) \
    i_prop    (X,Y, intern,     bool,           read_model_abort) \
    i_prop    (X,Y, intern,     emember,        in_assign) \
    i_prop    (X,Y, intern,     array,          spaces) \
    i_prop    (X,Y, intern,     map,            include) \
    i_prop    (X,Y, intern,     int,            expr_level) \
    i_prop    (X,Y, intern,     int,            parens_depth) \
    i_prop    (X,Y, intern,     i32,            statement_count) \
    i_prop    (X,Y, public,     path,           src_loc) \
    i_prop    (X,Y, public,     path,           file) \
    i_prop    (X,Y, public,     path,           project_path) \
    i_prop    (X,Y, public,     language,       std) \
    i_prop    (X,Y, public,     map,            defs) \
    i_prop    (X,Y, public,     map,            codegens) \
    i_prop    (X,Y, public,     string,         git_service) \
    i_prop    (X,Y, public,     string,         git_owner) \
    i_prop    (X,Y, public,     string,         git_project) \
    i_prop    (X,Y, public,     string,         source_raw) \
    i_prop    (X,Y, public,     bool,           single) \
    i_prop    (X,Y, public,     map,            import_cache) \
    i_method  (X,Y, public,     silver,         load_module, path) \
    i_method  (X,Y, public,     enode,          parse_member_expr, emember) \
    i_method  (X,Y, public,     none,           incremental_resolve) \
    i_method  (X,Y, public,     token,          next) \
    i_method  (X,Y, public,     token,          prev) \
    i_method  (X,Y, public,     token,          navigate, i32) \
    i_method  (X,Y, public,     token,          consume) \
    i_method  (X,Y, public,     token,          peek) \
    i_method  (X,Y, public,     token,          element, num) \
    i_method  (X,Y, public,     num,            current_line) \
    i_method  (X,Y, public,     bool,           next_is_alpha) \
    i_method  (X,Y, public,     bool,           next_indent) \
    i_method  (X,Y, public,     enode,          read_node, Au_t, model, array) \
    i_method  (X,Y, public,     enode,          parse_ternary, enode, model, array) \
    i_method  (X,Y, public,     enode,          parse_assignment, emember, string) \
    i_method  (X,Y, public,     token,          read_if, symbol) \
    i_method  (X,Y, public,     Au,              read_literal, Au_t) \
    i_method  (X,Y, public,     string,         read_string) \
    i_method  (X,Y, public,     string,         read_alpha) \
    i_method  (X,Y, public,     string,         read_alpha_any) \
    i_method  (X,Y, public,     string,         peek_alpha) \
    i_method  (X,Y, public,     bool,           next_is_neighbor) \
    i_method  (X,Y, public,     emember,        read_def) \
    i_method  (X,Y, public,     string,         peek_def) \
    i_method  (X,Y, public,     string,         peek_keyword) \
    i_method  (X,Y, public,     string,         read_keyword) \
    i_method  (X,Y, public,     Au,              read_bool) \
    i_method  (X,Y, public,     Au,              read_numeric) \
    i_method  (X,Y, public,     array,          parse_const, array) \
    i_method  (X,Y, public,     string,         read_assign, ARef, ARef) \
    i_method  (X,Y, public,     string,         location) \
    i_method  (X,Y, public,     none,           parse) \
    i_method  (X,Y, public,     i32,            build) \
    i_ctr     (X,Y, public,     path) \
    i_override(X,Y, method,     build_initializer) \
    i_override(X,Y, method,     init)
declare_class(silver)


#define flag_schema(X,Y,...) \
    i_prop(X,Y, public, string, name) \
    i_prop(X,Y, public, bool,   is_lib) \
    i_prop(X,Y, public, bool,   is_cflag) \
    i_prop(X,Y, public, bool,   is_static) \
    i_override(X,Y, cast, string)
declare_class(flag)

#define import_schema(X,Y,...) \
    i_prop(X,Y, public, codegen, codegen) \
    i_prop(X,Y, public, silver,  external) \
    i_prop(X,Y, public, array,   tokens) \
    i_prop(X,Y, public, array,   module_paths) \
    i_prop(X,Y, public, array,   include_paths) \
    s_method(X,Y, public, enode, parse, silver)
declare_class(import)



#ifndef __cplusplus
#define export_schema(X,Y,...) \
    s_method(X,Y, public, enode, parse, silver)
declare_class_2(export, model)
#endif

// major change to model here, with most work on software import happening in import
// process will perform actions needed by silver-only import
// does import also perform silver compilation, or stand-alone C compilation?
// it might make sense to do so; inter-dependency is what is of issue.  import would need
// to use silver at a binary level in that case (which to me is simpler)
// it is the interface that we do not have.  for this, do we want .m standard?  (Au-reflect emission)
// this works for silver, C and possibly others.  the two are what we want to handle for now
// unclear what the path is for project imports.  clearly there would be multiple .m reflection interfaces
// in the case of standard C we would use typical Clang Indexer service
// import url is going to infer the project type, internal to  import
//     <header> may be part of the syntax, if we are to use a specific header
// import url -llibrary
//     include <something>

*/

#endif