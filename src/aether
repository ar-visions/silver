#ifndef _ETHER_
#define _ETHER_

/// @brief the aether should be considered mysterious, and magical.
/// to make effective debuggable LL code, one has to employ multiple 
/// APIs simultaneously (IR & DBG) and its easy for that to take 
/// over the syntax

/// we internalize LLVM here, and what we expose is simple bindings
/// by A-type driven types.  its just how you want to 'start' building
/// a language, like silver!

typedef struct _aether*       aether;
typedef struct _model*       model;
typedef struct _emember*      emember;
typedef struct _record*      record;
typedef struct _enode*       enode;
typedef struct _fn*          fn;

#define comparison_schema(E,T,Y,...) \
    enum_value(E,T,Y, equals,            32) \
    enum_value(E,T,Y, not_equals,        33) \
    enum_value(E,T,Y, u_greater_than,    34) \
    enum_value(E,T,Y, u_greater_than_e,  35) \
    enum_value(E,T,Y, u_less_than,       36) \
    enum_value(E,T,Y, u_less_than_e,     37) \
    enum_value(E,T,Y, s_greater_than,    38) \
    enum_value(E,T,Y, s_greater_than_e,  39) \
    enum_value(E,T,Y, s_less_than,       40) \
    enum_value(E,T,Y, s_less_than_e,     41)
declare_enum(comparison)

#define token_schema(X,Y,...) \
    i_prop      (X,Y,  public,  path,       source) \
    i_prop      (X,Y,  public,  num,        line) \
    i_prop      (X,Y,  public,  num,        column) \
    i_prop      (X,Y,  public,  num,        indent) \
    i_prop      (X,Y,  public,  Au,          literal) \
    i_prop      (X,Y,  public,  aether,     mod) \
    i_method    (X,Y,  public,  Au_t,      get_type) \
    i_method    (X,Y,  public,  string,     location) \
    i_override  (X,Y,  ctr,     cstr) \
    i_override  (X,Y,  method,  init) \
    i_override  (X,Y,  method,  copy)
declare_class_2(token, string)


#define interface_schema(E,T,Y,...) \
    enum_value(E,T,Y, undefined,  0) \
    enum_value(E,T,Y, intern,     1) \
    enum_value(E,T,Y, public,     2) \
    enum_value(E,T,Y, context,    3)
declare_enum(interface)

/*
#define reference_schema(E,T,Y,...) \
    enum_value(E,T,Y, value,      0) \
    enum_value(E,T,Y, pointer,    1) \
    enum_value(E,T,Y, constant,   2)
declare_enum(reference)
*/

// mem is for is_type members
#define mschema_schema(X,Y,...) \
    i_prop(X,Y, public, emember, schema_type) \
    i_prop(X,Y, public, emember, schema_f) \
    i_prop(X,Y, public, emember, schema_info) \
    i_prop(X,Y, public, emember, schema_i)
declare_class(mschema)

forward(structure)

#define model_schema(X,Y,...)\
    i_prop    (X,Y, required,   aether,           mod, meta, weak) \
    i_prop    (X,Y, public,     emember,          mem, weak) \
    i_prop    (X,Y, public,     model,            parent) \
    i_prop    (X,Y, public,     Au_t,             atype_src) \
    i_prop    (X,Y, public,     model,            src) \
    i_prop    (X,Y, public,     bool,             is_ref) \
    i_prop    (X,Y, public,     bool,             is_map) \
    i_prop    (X,Y, public,     bool,             is_array) \
    i_prop    (X,Y, public,     bool,             is_global) \
    i_prop    (X,Y, public,     bool,             is_const) \
    i_prop    (X,Y, public,     bool,             is_system) \
    i_prop    (X,Y, public,     bool,             is_typeid) \
    i_prop    (X,Y, public,     bool,             is_internal) \
    i_prop    (X,Y, public,     bool,             is_module_init) \
    i_prop    (X,Y, public,     bool,             user_built) \
    i_prop    (X,Y, public,     bool,             open) \
    i_prop    (X,Y, public,     mschema,          schema) \
    i_prop    (X,Y, public,     bool,             use_count) \
    i_prop    (X,Y, public,     i64,              count) \
    i_prop    (X,Y, public,     shape,            shape) \
    i_prop    (X,Y, public,     sz,               size_bits) \
    i_prop    (X,Y, public,     sz,               alignment_bits) \
    i_prop    (X,Y, public,     map,              members) \
    i_prop    (X,Y, public,     path,             imported_from) \
    i_prop    (X,Y, public,     string,           extern_name) \
    i_prop    (X,Y, public,     array,            body) \
    i_prop    (X,Y, intern,     LLVMScope,        scope,      as, ARef) \
    i_prop    (X,Y, intern,     LLVMTypeRef,      type,       as, ARef) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,  debug,      as, ARef) \
    i_prop    (X,Y, intern,     model,            ptr) \
    i_prop    (X,Y, public,     bool,             finalized) \
    i_prop    (X,Y, intern,     model,            init_top) \
    i_prop    (X,Y, public,     emember,          mem_init) \
    i_prop    (X,Y, public,     structure,        schema_type) \
    i_method  (X,Y, public,     array,            class_list,    model, bool) \
    i_method  (X,Y, public,     array,            field_list,    model, bool) \
    i_method  (X,Y, public,     model,            typed) \
    s_method  (X,Y, public,     string,           keyword) \
    i_method  (X,Y, public,     model,            pointer) \
    i_method  (X,Y, public,     emember,          convertible,   model) \
    i_method  (X,Y, public,     emember,          castable,      model) \
    i_method  (X,Y, public,     emember,          constructable, model) \
    i_method  (X,Y, public,     emember,          find_member,   string, Au_t) \
    i_override(X,Y, cast,       string) \
    i_override(X,Y, method,     init)
declare_class(model)


#define catcher_schema(X,Y,...) \
    i_prop(X,Y, public, map, team) \
    i_prop(X,Y, intern, LLVMBasicBlockRef, block, as, ARef)
declare_class_2(catcher, model)




// some models are simple sub-classes to indicate their use
// use members on model for args
#define eargs_schema(X,Y,...) \
    i_prop(X,Y, public, bool, is_ext) \
    i_override(X,Y, method, init)
declare_class_2(eargs, model)


#define macro_schema(X,Y,...) \
    i_prop(X,Y, public, array, def) \
    i_prop(X,Y, public, array, params) \
    i_prop(X,Y, public, bool,  va_args) \
    i_method(X,Y, public, array, expand, array, map)
declare_class_2(macro, model)


#define format_attr_schema(X,Y,...) \
    i_prop(X,Y, required, string, type) \
    i_prop(X,Y, public,   i32,    format_index) \
    i_prop(X,Y, public,   i32,    arg_index)
declare_class(format_attr)


// codegen is given a function with no body, along with an array of [ array of media types ]
// supported types are string, image, resource file
// question is does this wait for the user on the system, or does it return when code is generated at all
// the user should sign-off on code with an accept statement, true, or some keyword
#define codegen_schema(X,Y,...) \
    i_method(X,Y, public, array, generate_fn, fn, array) \
    i_prop(X,Y, public, i32, pad)
declare_class(codegen)

#define fn_schema(X,Y,...) \
    i_prop(X,Y, public,     bool,                   is_cast) \
    i_prop(X,Y, public,     bool,                   is_ctr) \
    i_prop(X,Y, public,     bool,                   is_idx) \
    i_prop(X,Y, public,     OPType,                 is_oper) \
    i_prop(X,Y, public,     bool,                   is_override) \
    i_prop(X,Y, public,     bool,                   is_ifinal) \
    i_prop(X,Y, public,     bool,                   is_global_ctr) \
    i_prop(X,Y, public,     bool,                   is_guarded) \
    i_prop(X,Y, public,     bool,                   is_elsewhere) \
    i_prop(X,Y, public,     bool,                   va_args) \
    i_prop(X,Y, public,     model,                  rtype) \
    i_prop(X,Y, public,     array,                  rmeta) \
    i_prop(X,Y, public,     eargs,                  args) \
    i_prop(X,Y, public,     record,                 payload) \
    i_prop(X,Y, public,     bool,                   exported) \
    i_prop(X,Y, public,     model,                  instance) \
    i_prop(X,Y, public,     bool,                   single_expr) \
    i_prop(X,Y, public,     emember,                target) \
    i_prop(X,Y, public,     emember,                main_member) \
    i_prop(X,Y, public,     AFlag,                  function_type) \
    i_prop(X,Y, public,     codegen,                cgen) \
    i_prop(X,Y, intern,     format_attr,            format) \
    i_prop(X,Y, intern,     LLVMMetadataRef,        last_dbg,  as, ARef) \
    i_prop(X,Y, intern,     LLVMBasicBlockRef,      entry,     as, ARef) \
    i_prop(X,Y, intern,     LLVMValueRef,           value,     as, ARef) \
    i_prop(X,Y, intern,     LLVMTypeRef*,           arg_types, as, ARef) \
    i_prop(X,Y, intern,     num,                    arg_count) \
    i_method  (X,Y, public, none, use) \
    i_override(X,Y, method, init)
declare_class_2(fn, model)


#define clang_cc_schema(X,Y,...) \
    i_prop  (X,Y, public, aether,   mod) \
    i_prop  (X,Y, public, handle,   compiler) \
    i_prop  (X,Y, public, handle,   PP) \
    i_prop  (X,Y, public, handle,   ctx) \
    i_prop  (X,Y, public, handle,   consumer) \
    i_prop  (X,Y, public, handle,   S) \
    i_prop  (X,Y, public, handle,   P) \
    i_prop  (X,Y, public, handle,   module)
declare_class(clang_cc)


#define statements_schema(X,Y,...) \
    i_override(X,Y, method, init)
declare_class_2(statements, model)

typedef struct _schematic* schematic;
 
// replaces model's use of:
// i_prop(X,Y, public, string, namespace_name)

#define Namespace_schema(X,Y,...) \
    i_prop    (X,Y, public, Namespace, namespace_parent) \
    i_prop    (X,Y, public, string, namespace_name) \
    i_prop    (X,Y, public, bool,   namespace_inline)
declare_class_2(Namespace, model)

// for each field, f_* name-bound class, enum or primitive
#define record_schema(X,Y,...) \
    i_prop    (X,Y, public, token,  ident) \
    i_prop    (X,Y, public, array,  meta) \
    i_prop    (X,Y, public, bool,   parsing) \
    i_prop    (X,Y, public, bool,   is_abstract) \
    i_prop    (X,Y, public, i32,    total_members) \
    i_prop    (X,Y, public, bool,   expect_members) \
    i_override(X,Y, method,         init)
declare_class_3(record, Namespace, model)

#define Class_schema(X,Y,...)
declare_class_4(Class, record, Namespace, model)

#define structure_schema(X,Y,...)
declare_class_4(structure, record, Namespace, model)

#define enumeration_schema(X,Y,...) \
    i_prop    (X,Y, public, model, atype) \
    i_prop    (X,Y, public, map,   global_values) \
    i_override(X,Y, method, init)
declare_class_3(enumeration, Namespace, model)

#define uni_schema(X,Y,...)
declare_class_4(uni, record, Namespace, model)


/// the base helps us require the two args we need for nodes
/// we are also coupling type along inside enode, and this must be set properly with value macro
/// all enode values must contain its aether def.
/// otherwise we are performing hash lookups, which is more complex and slower, 
/// with less data stored
forward(emember)

#define enode_schema(X,Y,...)\
    i_prop    (X,Y, public,     token,                  name) \
    i_prop    (X,Y, public,     aether,                 mod) \
    i_prop    (X,Y, required,   model,                  mdl) \
    i_prop    (X,Y, public,     array,                  meta) \
    i_prop    (X,Y, public,     bool,                   explicit_ref) \
    i_prop    (X,Y, public,     Au,                     literal) \
    i_prop    (X,Y, public,     num,                    line) \
    i_prop    (X,Y, public,     num,                    column) \
    i_prop    (X,Y, public,     bool,                   loaded) \
    i_prop    (X,Y, public,     array,                  expressions) \
    i_prop    (X,Y, intern,     LLVMValueRef,           value, as, ARef) \
    i_method  (X,Y, public,     enode, access, string) \
    i_method  (X,Y, public,     enode, access_guard, string)
declare_class(enode)


// if ref is set, its a reference to a member with type definition (model, struct, ref)
#define emember_schema(X,Y,...) \
    i_prop    (X,Y, public,     interface,              access) \
    i_prop    (X,Y, public,     array,                  aliases, meta, string) \
    i_prop    (X,Y, public,     model,                  context, meta, weak) \
    i_prop    (X,Y, public,     model,                  membership, meta, weak) \
    i_prop    (X,Y, public,     array,                  meta_args) \
    i_prop    (X,Y, public,     bool,                   finalized) \
    i_prop    (X,Y, public,     aether,                 is_module) \
    i_prop    (X,Y, public,     bool,                   is_require) \
    i_prop    (X,Y, public,     bool,                   is_inlay) \
    i_prop    (X,Y, public,     bool,                   is_const) \
    i_prop    (X,Y, public,     bool,                   is_assigned) \
    i_prop    (X,Y, public,     bool,                   is_type) \
    i_prop    (X,Y, public,     bool,                   is_func) \
    i_prop    (X,Y, public,     bool,                   is_arg) \
    i_prop    (X,Y, public,     bool,                   is_global) \
    i_prop    (X,Y, public,     bool,                   is_formatter) \
    i_prop    (X,Y, public,     bool,                   is_decl) \
    i_prop    (X,Y, public,     bool,                   is_hidden) \
    i_prop    (X,Y, public,     bool,                   is_codegen) \
    i_prop    (X,Y, public,     Au,                      override_offset_bits) \
    i_prop    (X,Y, public,     Au,                      override_size_bits) \
    i_prop    (X,Y, public,     Au,                      override_alignment_bits) \
    i_prop    (X,Y, public,     path,                   imported_from) \
    i_prop    (X,Y, public,     Au,                      initializer) \
    i_prop    (X,Y, intern,     i32,                    offset_bits) \
    i_prop    (X,Y, intern,     i32,                    index) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        debug, as, ARef) \
    i_method  (X,Y, public,     none,    finalize) \
    i_method  (X,Y, public,     none,    release) \
    i_method  (X,Y, public,     bool,    has_value) \
    i_method  (X,Y, public,     none,    set_value,     Au) \
    i_override(X,Y, method,     init)
declare_class_2(emember, enode)


#define code_schema(X,Y,...) \
    i_prop    (X,Y, intern, LLVMBasicBlockRef, block, as, ARef) \
    i_prop    (X,Y, public, aether,  mod) \
    i_prop    (X,Y, public, symbol, label) \
    i_method  (X,Y, public, none,   seek_end) \
    i_override(X,Y, method, init)
declare_class(code)

#define ident_schema(X,Y,...) \
    i_prop(X,Y, public, model, mdl) \
    i_ctr(X,Y, public, model)
declare_class(ident)

#define static_array_schema(X,Y,...)
declare_class_2(static_array, array)


#define aether_schema(X,Y,...)\
    i_prop    (X,Y, public,     path,        source) \
    i_prop    (X,Y, public,     path,        install) \
    i_prop    (X,Y, public,     array,       framework_paths) \
    i_prop    (X,Y, public,     array,       lib_paths) \
    i_prop    (X,Y, public,     path,        isysroot) \
    i_prop    (X,Y, public,     path,        isystem) \
    i_prop    (X,Y, public,     path,        resource_dir) \
    i_prop    (X,Y, public,     array,       sys_inc_paths) \
    i_prop    (X,Y, public,     array,       sys_exc_paths) \
    i_prop    (X,Y, public,     array,       include_paths) \
    i_prop    (X,Y, public,     array,       shared_libs) \
    i_prop    (X,Y, public,     bool,        delegate) \
    i_prop    (X,Y, public,     bool,        with_debug) \
    i_prop    (X,Y, intern,     bool,        is_Au_import) \
    i_prop    (X,Y, public,     path,        current_include) \
    i_prop    (X,Y, intern,     fn,          current_fn) \
    i_prop    (X,Y, public,     bool,        in_macro) \
    i_prop    (X,Y, public,     bool,        in_ref) \
    i_prop    (X,Y, public,     bool,        is_library) \
    i_prop    (X,Y, public,     model,       top) \
    i_prop    (X,Y, public,     array,       lex) \
    i_prop    (X,Y, public,     bool,        cmode) \
    i_prop    (X,Y, public,     callback,    parse_f) \
    i_prop    (X,Y, public,     callback_extra, parse_expr) \
    i_prop    (X,Y, public,     callback_extra, read_model) \
    i_prop    (X,Y, public,     map,         base) \
    i_prop    (X,Y, public,     enode,       last_return) \
    i_prop    (X,Y, public,     model,       userspace) \
    i_prop    (X,Y, intern,     array,       finalizing) \
    i_prop    (X,Y, intern,     bool,        no_const) \
    i_prop    (X,Y, intern,     LLVMExecutionEngineRef, jit,               as, ARef) \
    i_prop    (X,Y, intern,     LLVMBasicBlockRef,      current_if_block,  as, ARef) \
    i_prop    (X,Y, intern,     LLVMModuleRef,          module,            as, ARef) \
    i_prop    (X,Y, intern,     LLVMContextRef,         module_ctx,        as, ARef) \
    i_prop    (X,Y, intern,     LLVMBuilderRef,         builder,           as, ARef) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        file,              as, ARef) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        compile_unit,      as, ARef) \
    i_prop    (X,Y, intern,     LLVMDIBuilderRef,       dbg_builder,       as, ARef) \
    i_prop    (X,Y, intern,     LLVMTargetRef,          target,            as, ARef) \
    i_prop    (X,Y, intern,     LLVMTargetDataRef,      target_data,       as, ARef) \
    i_prop    (X,Y, intern,     LLVMTargetMachineRef,   target_machine,    as, ARef) \
    i_prop    (X,Y, intern,     cstr,        target_triple) \
    i_prop    (X,Y, public,     bool,        left_hand) \
    i_prop    (X,Y, public,     array,       tokens) \
    i_prop    (X,Y, public,     array,       stack) \
    i_prop    (X,Y, public,     num,         cursor) \
    i_prop    (X,Y, public,     map,         instances) \
    i_prop    (X,Y, public,     bool,        verbose) \
    i_prop    (X,Y, public,     bool,        no_build) \
    i_prop    (X,Y, public,     i32,         state) \
    i_method  (X,Y, public,     none,        context,            ARef, ARef, Au_t) \
    i_method  (X,Y, public,     none,        reinit_startup) \
    i_method  (X,Y, public,     emember,     initializer) \
    i_method  (X,Y, public,     path,        lookup_include,     string) \
    i_method  (X,Y, public,     none,        build_info,         path) \
    i_method  (X,Y, public,     none,        Au_import,          path) \
    i_method  (X,Y, public,     none,        push_state,         array, num) \
    i_method  (X,Y, public,     none,        push_current) \
    i_method  (X,Y, public,     none,        pop_state,          bool) \
    i_method  (X,Y, public,     enode,       e_fn_return,        Au) \
    i_method  (X,Y, public,     enode,       e_null,             model) \
    i_method  (X,Y, public,     enode,       e_default_value,    model, array) \
    i_method  (X,Y, public,     enode,       e_builder,          subprocedure) \
    i_method  (X,Y, public,     none,        build_initializer,  fn) \
    i_method  (X,Y, public,     enode,       e_element,          enode,      Au) \
    i_method  (X,Y, public,     none,        e_cmp_code,         enode,      comparison, enode, code, code) \
    i_method  (X,Y, public,     enode,       e_cmp,              enode, enode) \
    i_method  (X,Y, public,     none,        e_branch,           code) \
    i_method  (X,Y, public,     enode,       e_break,            catcher) \
    i_method  (X,Y, public,     none,        e_memcpy,           enode, enode, model) \
    i_method  (X,Y, public,     emember,     compatible,         record,     string, AFlag, array) \
    i_method  (X,Y, public,     none,        register_member,    emember, bool) \
    i_method  (X,Y, public,     emember,     register_model,     model,   string, bool) \
    i_method  (X,Y, public,     enode,       e_operand,          Au,          model, array) \
    i_method  (X,Y, public,     enode,       e_op,               OPType,     string, Au, Au) \
    i_method  (X,Y, public,     enode,       e_load,             emember, emember) \
    i_method  (X,Y, public,     enode,       e_typeid,           model) \
    i_method  (X,Y, public,     enode,       e_meta_ids,         array) \
    i_method  (X,Y, public,     enode,       e_eval,             string) \
    i_method  (X,Y, public,     enode,       e_interpolate,      string) \
    i_method  (X,Y, public,     enode,       e_const_array,      model, array) \
    i_method  (X,Y, public,     enode,       e_offset,           enode,      Au) \
    i_method  (X,Y, public,     enode,       e_switch,           enode, map, array, subprocedure, subprocedure) \
    i_method  (X,Y, public,     enode,       e_native_switch,    enode, map, array, subprocedure, subprocedure) \
    i_method  (X,Y, public,     enode,       e_for,              array, array, array, array, subprocedure, subprocedure, subprocedure, subprocedure) \
    i_method  (X,Y, public,     enode,       e_loop,             array,      array, subprocedure, subprocedure, bool) \
    i_method  (X,Y, public,     enode,       e_if_else,          array,      array, subprocedure, subprocedure) \
    i_method  (X,Y, public,     enode,       e_ternary,          enode,      enode, enode) \
    i_method  (X,Y, public,     enode,       e_primitive_convert, enode,     model) \
    i_method  (X,Y, public,     enode,       e_noop,             model) \
    i_method  (X,Y, public,     enode,       e_addr_of,          enode,      model) \
    i_method  (X,Y, public,     enode,       e_bitwise_not,      enode) \
    i_method  (X,Y, public,     enode,       e_not,              enode) \
    i_method  (X,Y, public,     none,        e_inc,              enode,      num) \
    i_method  (X,Y, public,     none,        e_print_node,       enode) \
    i_method  (X,Y, public,     emember,     e_var,              model,      string) \
    i_method  (X,Y, public,     enode,       e_or,               Au,          Au) \
    i_method  (X,Y, public,     enode,       e_xor,              Au,          Au) \
    i_method  (X,Y, public,     enode,       e_and,              Au,          Au) \
    i_method  (X,Y, public,     enode,       e_add,              Au,          Au) \
    i_method  (X,Y, public,     enode,       e_sub,              Au,          Au) \
    i_method  (X,Y, public,     enode,       e_mul,              Au,          Au) \
    i_method  (X,Y, public,     enode,       e_div,              Au,          Au) \
    i_method  (X,Y, public,     enode,       e_create,             model,      array, Au) \
    i_method  (X,Y, public,     enode,       e_zero,               enode) \
    i_method  (X,Y, public,     enode,       e_assign,             enode,      Au, OPType) \
    i_method  (X,Y, public,     enode,       e_eq,                 enode,      enode) \
    i_method  (X,Y, public,     enode,       e_not_eq,             enode,      enode) \
    i_method  (X,Y, public,     enode,       e_fn_call,            fn,         enode,    array) \
    i_method  (X,Y, public,     enode,       e_is,               enode,      Au) \
    i_method  (X,Y, public,     enode,       e_inherits,         enode,      Au) \
    i_method  (X,Y, public,     emember,     lookup2,            Au,          Au_t) \
    i_method  (X,Y, public,     model,       context_model,      Au_t) \
    i_method  (X,Y, public,     path,        include,            Au, ARef) \
    i_method  (X,Y, public,     none,        llflag,             symbol,     i32) \
    i_method  (X,Y, public,     model,       push,               model) \
    i_method  (X,Y, public,     model,       pop) \
    i_method  (X,Y, public,     model,       top) \
    i_method  (X,Y, public,     bool,        emit,           ARef,       ARef) \
    i_method  (X,Y, public,     model,       return_type, ARef) \
    i_override(X,Y, method,     init) \
    i_override(X,Y, method,     dealloc)
declare_class_2(aether, model)

// i_vargs   (X,Y, public,     none,       eprint,         symbol) \

bool is_void     (model);
bool is_bool     (model);
bool is_float    (model);
bool is_double   (model);
bool is_realistic(model);
bool is_integral (model);
bool is_signed   (model);
bool is_unsigned (model);
model is_record  (model);
bool is_generic  (model);
model is_class   (model);
bool is_enumeration(model);
model is_struct  (model);
bool is_ref      (model);

#endif