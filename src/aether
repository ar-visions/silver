#ifndef _AETHER2_
#define _AETHER2_

forward(aether)

#define etype_schema(X,Y,...)\
    M(X,Y, i, prop, public,   Au_t,             au) \
    M(X,Y, i, prop, public,   aether,           mod) \
    M(X,Y, i, prop, public,   etype,            schema) \
    M(X,Y, i, prop, public,   tokens,           body) \
    M(X,Y, i, prop, public,   bool,             is_schema) \
    M(X,Y, i, prop, public,   bool,             is_implemented) \
    M(X,Y, i, prop, public,   i32,              size_bits) \
    M(X,Y, i, prop, public,   i32,              align_bits) \
    M(X,Y, i, prop, intern,   LLVMScope,        scope, as, ARef) \
    M(X,Y, i, prop, intern,   LLVMTypeRef,      type,  as, ARef) \
    M(X,Y, i, prop, intern,   LLVMMetadataRef,  debug, as, ARef) \
    M(X,Y, i, method, public, etype, resolve) \
    M(X,Y, i, override, method, init) \
    M(X,Y, i, override, cast,   Au_t) \
    M(X,Y, i, override, cast,   string)
declare_class(etype)

#define aether_schema(X,Y,...)\
    M(X,Y, i, prop,  public, string,                 name) \
    M(X,Y, i, prop,  public, path,                   source) \
    M(X,Y, i, prop,  public, path,                   project_path) \
    M(X,Y, i, prop,  public, path,                   current_inc) \
    M(X,Y, i, prop,  public, array,                  libs) \
    M(X,Y, i, prop,  public, array,                  lexical) \
    M(X,Y, i, prop,  public, bool,                   is_Au_import) \
    M(X,Y, i, prop,  public, Au_t,                   au_module) \
    M(X,Y, i, prop,  public, array,                  sys_inc_paths) \
    M(X,Y, i, prop,  public, array,                  sys_exc_paths) \
    M(X,Y, i, prop,  public, array,                  include_paths) \
    M(X,Y, i, prop,  public, array,                  framework_paths) \
    M(X,Y, i, prop,  public, array,                  lib_paths) \
    M(X,Y, i, prop,  public, path,                   isysroot) \
    M(X,Y, i, prop,  public, path,                   resource_dir) \
    M(X,Y, i, prop,  public, path,                   isystem) \
    M(X,Y, i, prop,  public, bool,                   verbose) \
    M(X,Y, i, prop,  public, path,                   install) \
    M(X,Y, i, prop,  public, bool,                   cmode) \
    M(X,Y, i, prop,  public, callback_extra,         parse_f) \
    M(X,Y, i, prop,  public, callback_extra, parse_expr) \
    M(X,Y, i, prop,  public, callback_extra, read_model) \
    M(X,Y, i, prop,  intern, LLVMExecutionEngineRef, jit,               as, ARef) \
    M(X,Y, i, prop,  intern, LLVMBasicBlockRef,      current_if_block,  as, ARef) \
    M(X,Y, i, prop,  intern, LLVMModuleRef,          module,            as, ARef) \
    M(X,Y, i, prop,  intern, LLVMContextRef,         module_ctx,        as, ARef) \
    M(X,Y, i, prop,  intern, LLVMBuilderRef,         builder,           as, ARef) \
    M(X,Y, i, prop,  intern, LLVMMetadataRef,        file,              as, ARef) \
    M(X,Y, i, prop,  intern, LLVMMetadataRef,        compile_unit,      as, ARef) \
    M(X,Y, i, prop,  intern, LLVMDIBuilderRef,       dbg_builder,       as, ARef) \
    M(X,Y, i, prop,  intern, LLVMTargetRef,          target,            as, ARef) \
    M(X,Y, i, prop,  intern, LLVMTargetDataRef,      target_data,       as, ARef) \
    M(X,Y, i, prop,  intern, LLVMTargetMachineRef,   target_machine,    as, ARef) \
    M(X,Y, i, prop,  intern, cstr,                   target_triple) \
    M(X,Y, i, prop,  intern, array,                  registry) \
    M(X,Y, i, prop,  public, tokens,                 tokens) \
    M(X,Y, i, prop,  public, num,                    cursor) \
    M(X,Y, i, prop,  public, array,                  stack) \
    M(X,Y, i, method, public, none,   push_tokens,    tokens, num) \
    M(X,Y, i, method, public, none,   pop_tokens,     bool) \
    M(X,Y, i, method, public, path,   lookup_include, string) \
    M(X,Y, i, method, public, path,   include,        Au, ARef) \
    M(X,Y, i, method, public, Au_t,   top_scope) \
    M(X,Y, i, method, public, none,   push_scope, Au) \
    M(X,Y, i, method, public, none,   import_models) \
    M(X,Y, i, override, method, init)
declare_class_2(aether, etype);

#define enode_schema(X,Y,...)\
    M(X,Y, i, prop, public,   enode,            target) \
    M(X,Y, i, prop, public,   etype,            t) \
    M(X,Y, i, prop, public,   aether,           mod) \
    M(X,Y, i, prop, intern,   LLVMValueRef,     value,  as, ARef) \
    M(X,Y, i, override, cast, Au_t)
declare_class(enode)

#define aclang_cc_schema(X,Y,...) \
    i_prop  (X,Y, public, aether,   mod) \
    i_prop  (X,Y, public, handle,   compiler) \
    i_prop  (X,Y, public, handle,   PP) \
    i_prop  (X,Y, public, handle,   ctx) \
    i_prop  (X,Y, public, handle,   consumer) \
    i_prop  (X,Y, public, handle,   S) \
    i_prop  (X,Y, public, handle,   P) \
    i_prop  (X,Y, public, handle,   module)
declare_class(aclang_cc)

#define macro_schema(X,Y,...) \
    i_prop(X,Y, public, array, def) \
    i_prop(X,Y, public, array, params) \
    i_prop(X,Y, public, bool,  va_args) \
    i_method(X,Y, public, array, expand, array, map)
declare_class_2(macro, etype)

#define codegen_schema(X,Y,...) \
    i_method(X,Y, public, array, generate_fn, Au_t, array) \
    i_prop(X,Y, public, i32, pad)
declare_class(codegen)

#endif