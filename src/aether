#ifndef _AETHER2_
#define _AETHER2_

forward(aether)
forward(enode)
forward(code)
forward(catcher)
forward(codegen)

#define members(MDL, VAR) \
    for (int __i = 0; __i < (MDL)->members.count; __i++) \
        for (Au_t VAR = (Au_t)(MDL)->members.origin[__i]; VAR; VAR = NULL)
 
#define arg_list(MDL, VAR) \
    for (int __i = 0; __i < (MDL)->args.count; __i++) \
        for (Au_t VAR = (Au_t)(MDL)->args.origin[__i]; VAR; VAR = NULL)

#define arg_types(MDL, VAR) \
    for (int __i = 0; __i < (MDL)->args.count; __i++) \
        for (Au_t VAR = (Au_t)read_arg_type((Au_t)(MDL)->args.origin[__i]); VAR; VAR = NULL)

Au_t read_arg_type(Au_t stored_arg);

// templates needed
#define etype_schema(X,Y,...)\
    M(X,Y, i, prop, public,   Au_t,             au) \
    M(X,Y, i, prop, public,   array,            meta) \
    M(X,Y, i, prop, public,   array,            dims) \
    M(X,Y, i, prop, public,   aether,           mod) \
    M(X,Y, i, prop, public,   etype,            schema) \
    M(X,Y, i, prop, public,   etype,            suffix) \
    M(X,Y, i, prop, public,   tokens,           body) \
    M(X,Y, i, prop, public,   bool,             has_code) \
    M(X,Y, i, prop, public,   bool,             is_schema) \
    M(X,Y, i, prop, public,   bool,             is_elsewhere) \
    M(X,Y, i, prop, public,   bool,             user_built) \
    M(X,Y, i, prop, public,   bool,             parsing) \
    M(X,Y, i, prop, public,   path,             imported_from) \
    M(X,Y, i, prop, public,   codegen,          cgen) \
    M(X,Y, i, prop, public,   enode,            type_id) \
    M(X,Y, i, method, public, none,             implement) \
    M(X,Y, i, method, public, array,            class_list) \
    M(X,Y, i, method, public, etype,            resolve) \
    M(X,Y, i, guard,  public, etype,            canonical, etype) \
    M(X,Y, i, override, method, init) \
    M(X,Y, i, override, cast,   Au_t) \
    M(X,Y, i, override, cast,   string)
declare_class(etype)

#define emodule_schema(X,Y,...)
declare_class_2(emodule, etype)

#define statements_schema(X,Y,...)
declare_class_2(statements, etype)

// if we provide a singular function reference, i wonder if it shoudl be then be 'called'
// its a field syntax that optionally has no : set, and that sets default, or it calls the function
#define aether_schema(X,Y,...)\
    M(X,Y, i, prop,  public, string,    name) \
    M(X,Y, i, prop,  public, path,      source) \
    M(X,Y, i, prop,  public, path,      project_path) \
    M(X,Y, i, prop,  public, path,      current_inc) \
    M(X,Y, i, prop,  public, etype,     current_import) \
    M(X,Y, i, prop,  public, Au_t,      import_module) \
    M(X,Y, i, prop,  public, Au_t,      au_module) \
    M(X,Y, i, prop,  public, bool,      lock_schema) \
    M(X,Y, i, prop,  public, map,       props) \
    M(X,Y, i, prop,  public, map,       libs) \
    M(X,Y, i, prop,  public, map,       user_type_ids) \
    M(X,Y, i, prop,  public, array,     lexical) \
    M(X,Y, i, prop,  public, bool,      is_Au_import) \
    M(X,Y, i, prop,  public, bool,      in_ref) \
    M(X,Y, i, prop,  public, array,     sys_inc_paths) \
    M(X,Y, i, prop,  public, array,     sys_exc_paths) \
    M(X,Y, i, prop,  public, array,     include_paths) \
    M(X,Y, i, prop,  public, array,     framework_paths) \
    M(X,Y, i, prop,  public, array,     lib_paths) \
    M(X,Y, i, prop,  public, path,      isysroot) \
    M(X,Y, i, prop,  public, path,      resource_dir) \
    M(X,Y, i, prop,  public, path,      isystem) \
    M(X,Y, i, prop,  public, bool,      verbose) \
    M(X,Y, i, prop,  public, path,      install) \
    M(X,Y, i, prop,  public, bool,      is_library) \
    M(X,Y, i, prop,  public, bool,      cmode) \
    M(X,Y, i, prop,  public, bool,      no_build) \
    M(X,Y, i, prop,  public, bool,      no_const) \
    M(X,Y, i, prop,  public, bool,      is_const_op) \
    M(X,Y, i, prop,  public, bool,      is_delegate) \
    M(X,Y, i, prop,  public, i32,       stack_test) \
    M(X,Y, i, prop,  public, enode,     fn_init) \
    M(X,Y, i, prop,  public, callback_extra, parse_f) \
    M(X,Y, i, prop,  public, callback_extra, parse_expr) \
    M(X,Y, i, prop,  public, callback_extra, read_etype) \
    M(X,Y, i, prop,  intern, LLVMExecutionEngineRef, jit, as, ARef) \
    M(X,Y, i, prop,  intern, LLVMBasicBlockRef, current_if_block,  as, ARef) \
    M(X,Y, i, prop,  intern, LLVMModuleRef,     module,            as, ARef) \
    M(X,Y, i, prop,  intern, LLVMContextRef,    module_ctx,        as, ARef) \
    M(X,Y, i, prop,  intern, LLVMBuilderRef,    builder,           as, ARef) \
    M(X,Y, i, prop,  intern, LLVMMetadataRef,   file,              as, ARef) \
    M(X,Y, i, prop,  intern, LLVMMetadataRef,   compile_unit,      as, ARef) \
    M(X,Y, i, prop,  intern, LLVMDIBuilderRef,  dbg_builder,       as, ARef) \
    M(X,Y, i, prop,  intern, LLVMTargetRef,     target_ref,        as, ARef) \
    M(X,Y, i, prop,  intern, LLVMTargetDataRef, target_data,       as, ARef) \
    M(X,Y, i, prop,  intern, LLVMTargetMachineRef, target_machine, as, ARef) \
    M(X,Y, i, prop,  intern, cstr,              target_triple) \
    M(X,Y, i, prop,  intern, array,             registry) \
    M(X,Y, i, prop,  public, tokens,            tokens) \
    M(X,Y, i, prop,  public, num,               cursor) \
    M(X,Y, i, prop,  public, array,             stack) \
    M(X,Y, i, prop,  public, Au_t,              top) \
    M(X,Y, i, method, public,     none,        create_type_members, Au_t) \
    M(X,Y, i, method, public,     none,        output_schemas, enode) \
    M(X,Y, i, method, public,     enode,       module_initializer) \
    M(X,Y, i, method, public,     none,        import_Au, Au) \
    M(X,Y, i, method, public,     enode,       function, etype, string, etype, array, u8, u32, u8) \
    M(X,Y, i, method, public,     etype,       record, etype, etype, string, u32) \
    M(X,Y, i, method, public,     none,        reinit_startup) \
    M(X,Y, i, method, public,     enode,       e_alloc,            etype) \
    M(X,Y, i, method, public,     none,        e_fn_return,        Au) \
    M(X,Y, i, method, public,     enode,       e_null,             etype) \
    M(X,Y, i, method, public,     enode,       e_default_value,    etype) \
    M(X,Y, i, method, public,     enode,       e_builder,          subprocedure) \
    M(X,Y, i, method, public,     none,        build_initializer,  etype) \
    M(X,Y, i, method, public,     enode,       e_element,          enode,      Au) \
    M(X,Y, i, method, public,     none,        e_cmp_code,         enode,      comparison, enode, code, code) \
    M(X,Y, i, method, public,     enode,       e_cmp,              enode, enode) \
    M(X,Y, i, method, public,     none,        e_branch,           code) \
    M(X,Y, i, method, public,     enode,       e_break,            catcher) \
    M(X,Y, i, method, public,     none,        e_memcpy,           enode, enode, Au_t) \
    M(X,Y, i, method, public,     enode,       compatible,         etype, string, AFlag, array) \
    M(X,Y, i, method, public,     enode,       e_operand,          Au, etype) \
    M(X,Y, i, method, public,     enode,       e_op,               OPType,     string, Au, Au) \
    M(X,Y, i, method, public,     enode,       e_load,             enode, enode) \
    M(X,Y, i, method, public,     enode,       e_typeid,           etype) \
    M(X,Y, i, method, public,     enode,       e_meta_ids,         array) \
    M(X,Y, i, method, public,     enode,       e_eval,             string) \
    M(X,Y, i, method, public,     enode,       e_interpolate,      string) \
    M(X,Y, i, method, public,     enode,       e_const_array,      etype, array) \
    M(X,Y, i, method, public,     enode,       e_offset,           enode,      Au) \
    M(X,Y, i, method, public,     enode,       e_switch,           enode, map, array, subprocedure, subprocedure) \
    M(X,Y, i, method, public,     enode,       e_native_switch,    enode, map, array, subprocedure, subprocedure) \
    M(X,Y, i, method, public,     enode,       e_for,              array, array, array, array, subprocedure, subprocedure, subprocedure, subprocedure) \
    M(X,Y, i, method, public,     enode,       e_loop,             array,      array, subprocedure, subprocedure, bool) \
    M(X,Y, i, method, public,     enode,       e_if_else,          array,      array, subprocedure, subprocedure) \
    M(X,Y, i, method, public,     enode,       e_ternary,          enode,      enode, enode) \
    M(X,Y, i, method, public,     enode,       e_primitive_convert, enode,     etype) \
    M(X,Y, i, method, public,     enode,       e_noop,             etype) \
    M(X,Y, i, method, public,     enode,       e_addr_of,          enode,      etype) \
    M(X,Y, i, method, public,     enode,       e_bitwise_not,      enode) \
    M(X,Y, i, method, public,     enode,       e_not,              enode) \
    M(X,Y, i, method, public,     none,        e_inc,              enode,      num) \
    M(X,Y, i, method, public,     none,        e_print_node,       enode) \
    M(X,Y, i, method, public,     enode,       e_or,               Au,          Au) \
    M(X,Y, i, method, public,     enode,       e_xor,              Au,          Au) \
    M(X,Y, i, method, public,     enode,       e_and,              Au,          Au) \
    M(X,Y, i, method, public,     enode,       e_add,              Au,          Au) \
    M(X,Y, i, method, public,     enode,       e_sub,              Au,          Au) \
    M(X,Y, i, method, public,     enode,       e_mul,              Au,          Au) \
    M(X,Y, i, method, public,     enode,       e_div,              Au,          Au) \
    M(X,Y, i, method, public,     enode,       e_create,           etype, Au) \
    M(X,Y, i, method, public,     enode,       e_vector,           etype, enode) \
    M(X,Y, i, method, public,     enode,       e_zero,               enode) \
    M(X,Y, i, method, public,     enode,       e_assign,             enode,      Au, OPType) \
    M(X,Y, i, method, public,     enode,       e_eq,                 enode,      enode) \
    M(X,Y, i, method, public,     enode,       e_not_eq,           enode, enode) \
    M(X,Y, i, method, public,     enode,       e_fn_call,          enode,      array)  \
    M(X,Y, i, method, public,     enode,       e_is,               enode,      Au) \
    M(X,Y, i, method, public,     enode,       e_inherits,         enode,      Au) \
    M(X,Y, i, method, public,     none,        llflag,             symbol,     i32) \
    M(X,Y, i, method, public,     bool,        emit,           ARef,       ARef) \
    M(X,Y, i, method, public,     etype,       return_type) \
    M(X,Y, i, method, public, statements, context_code) \
    M(X,Y, i, method, public, enode,  context_func) \
    M(X,Y, i, method, public, etype,  context_class) \
    M(X,Y, i, method, public, etype,  context_struct) \
    M(X,Y, i, method, public, etype,  context_record) \
    M(X,Y, i, method, public, etype,  context_model, Au_t) \
    M(X,Y, i, method, public, none,   push_current) \
    M(X,Y, i, method, public, none,   push_tokens,    tokens, num) \
    M(X,Y, i, method, public, none,   pop_tokens,     bool) \
    M(X,Y, i, method, public, path,   lookup_include, string) \
    M(X,Y, i, method, public, path,   include,        Au, string, ARef) \
    M(X,Y, i, method, public, Au_t,   top_scope) \
    M(X,Y, i, method, public, none,   push_scope, Au) \
    M(X,Y, i, method, public, Au_t,   pop_scope) \
    M(X,Y, i, method, public, none,   import_models, Au_t) \
    M(X,Y, i, override, method, init)
declare_class_3(aether, emodule, etype);


#define catcher_schema(X,Y,...) \
    M(X,Y, i, prop, public, map, team) \
    M(X,Y, i, prop, intern, LLVMBasicBlockRef, block, as, ARef)
declare_class_2(catcher, etype)

#define code_schema(X,Y,...) \
    M(X,Y, i, prop, intern, LLVMBasicBlockRef, block, as, ARef) \
    M(X,Y, i, prop, public, aether,  mod) \
    M(X,Y, i, prop, public, symbol, label) \
    M(X,Y, i, method, public, none,   seek_end) \
    M(X,Y, i, override, method, init)
declare_class(code)

forward(evar)

#define enode_schema(X,Y,...)\
    M(X,Y, i, prop, public,   enode,            target) \
    M(X,Y, i, prop, public,   Au,               literal) \
    M(X,Y, i, prop, public,   u8,               arg_index) \
    M(X,Y, i, prop, public,   bool,             used) \
    M(X,Y, i, prop, public,   tokens,           initializer) \
    M(X,Y, i, prop, public,   bool,             loaded) \
    M(X,Y, i, prop, intern,   LLVMMetadataRef,  last_dbg, as, ARef) \
    M(X,Y, i, prop, intern,   LLVMValueRef,     value, as, ARef) \
    M(X,Y, i, prop, public,   enode,            args_node, as, ARef) \
    M(X,Y, i, prop, public,   enode,            context_node, as, ARef) \
    M(X,Y, i, prop, intern,   LLVMBasicBlockRef, entry,  as, ARef) \
    M(X,Y, i, method, public, Au,               literal_value, Au_t) \
    M(X,Y, i, method, public, enode,            access, string) \
    M(X,Y, i, method, public, enode,            retain) \
    M(X,Y, i, method, public, enode,            release) \
    M(X,Y, i, method, public, none,             inspect) \
    M(X,Y, i, override, cast,                   Au_t) \
    M(X,Y, i, override, method,                 init) \
    M(X,Y, i, override, method,                 dealloc)
declare_class_2(enode, etype)

#define evar_schema(X,Y,...) \
    M(X,Y, i, prop, public, map, placeholder)
declare_class_3(evar, enode, etype)

#define emeta_schema(X,Y,...) \
    M(X,Y, i, prop, public, i32, meta_index)
declare_class_2(emeta, etype)

#define aclang_cc_schema(X,Y,...) \
    M(X,Y, i, prop, public, aether,   mod) \
    M(X,Y, i, prop, public, handle,   compiler) \
    M(X,Y, i, prop, public, handle,   PP) \
    M(X,Y, i, prop, public, handle,   ctx) \
    M(X,Y, i, prop, public, handle,   consumer) \
    M(X,Y, i, prop, public, handle,   S) \
    M(X,Y, i, prop, public, handle,   P) \
    M(X,Y, i, prop, public, handle,   module)
declare_class(aclang_cc)

#define macro_schema(X,Y,...) \
    M(X,Y, i, prop, public, array, def) \
    M(X,Y, i, prop, public, array, params) \
    M(X,Y, i, prop, public, bool,  va_args) \
    M(X,Y, i, method, public, array, expand, array, map)
declare_class_2(macro, etype)

#define codegen_schema(X,Y,...) \
    M(X,Y, i, method, public, array, generate_fn, enode, array) \
    M(X,Y, i, prop, public, i32, pad)
declare_class(codegen)

#define static_array_schema(X,Y,...) \
    M(X,Y, i, prop, intern, bool, placeholder)
declare_class_3(static_array, array, collective)

#endif