#ifndef _ETHER_
#define _ETHER_

/// @brief the aether should be considered mysterious, and magical.
/// to make effective debuggable LL code, one has to employ multiple 
/// APIs simultaneously (IR & DBG) and its easy for that to take 
/// over the syntax

/// we internalize LLVM here, and what we expose is simple bindings
/// by A-type driven types.  its just how you want to 'start' building
/// a language, like silver!

typedef struct _aether*       aether;
typedef struct _model*       model;
typedef struct _emember*      emember;
typedef struct _record*      record;
typedef struct _enode*       enode;
typedef struct _fn*          fn;

#define comparison_schema(E,T,Y,...) \
    enum_value  (E,T,Y, equals,           32) \
    enum_value  (E,T,Y, not_equals,       1) \
    enum_value  (E,T,Y, u_greater_than,   2) \
    enum_value  (E,T,Y, u_greater_than_e, 3) \
    enum_value  (E,T,Y, u_less_than,      4) \
    enum_value  (E,T,Y, u_less_than_e,    5) \
    enum_value  (E,T,Y, s_greater_than,   6) \
    enum_value  (E,T,Y, s_greater_than_e, 7) \
    enum_value  (E,T,Y, s_less_than,      8) \
    enum_value  (E,T,Y, s_less_than_e,    9)
declare_enum(comparison)

#define token_schema(X,Y,...) \
    i_prop      (X,Y,  public,  path,       source) \
    i_prop      (X,Y,  public,  num,        line) \
    i_prop      (X,Y,  public,  num,        column) \
    i_prop      (X,Y,  public,  num,        indent) \
    i_prop      (X,Y,  public,  A,          literal) \
    i_method    (X,Y,  public,  AType,      get_type) \
    i_method    (X,Y,  public,  string,     location) \
    i_override  (X,Y,  ctr,     cstr) \
    i_override  (X,Y,  method,  init) \
    i_override  (X,Y,  method,  copy)
declare_class_2(token, string)


#define interface_schema(E,T,Y,...) \
    enum_value(E,T,Y, undefined,  0) \
    enum_value(E,T,Y, intern,     1) \
    enum_value(E,T,Y, public,     2) \
    enum_value(E,T,Y, context,    3)
declare_enum(interface)

/*
#define reference_schema(E,T,Y,...) \
    enum_value(E,T,Y, value,      0) \
    enum_value(E,T,Y, pointer,    1) \
    enum_value(E,T,Y, constant,   2)
declare_enum(reference)
*/


#define model_schema(X,Y,...)\
    i_prop    (X,Y, required,   aether,           mod, meta, weak) \
    i_prop    (X,Y, public,     token,            name) \
    i_prop    (X,Y, public,     string,           namespace_name) \
    i_prop    (X,Y, public,     model,            src) \
    i_prop    (X,Y, public,     bool,             is_ref) \
    i_prop    (X,Y, public,     bool,             is_map) \
    i_prop    (X,Y, public,     bool,             is_array) \
    i_prop    (X,Y, public,     bool,             is_user) \
    i_prop    (X,Y, public,     bool,             is_const) \
    i_prop    (X,Y, public,     bool,             is_system) \
    i_prop    (X,Y, public,     bool,             is_internal) \
    i_prop    (X,Y, public,     bool,             has_schema) \
    i_prop    (X,Y, public,     i64,              count) \
    i_prop    (X,Y, public,     shape,            shape) \
    i_prop    (X,Y, public,     sz,               size_bits) \
    i_prop    (X,Y, public,     sz,               alignment_bits) \
    i_prop    (X,Y, public,     map,              members) \
    i_prop    (X,Y, public,     path,             imported_from) \
    i_prop    (X,Y, public,     string,           extern_name) \
    i_prop    (X,Y, public,     array,            body) \
    i_prop    (X,Y, intern,     LLVMScope,        scope,      as, ARef) \
    i_prop    (X,Y, intern,     LLVMTypeRef,      type,       as, ARef) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,  debug,      as, ARef) \
    i_prop    (X,Y, intern,     model,            ptr) \
    i_prop    (X,Y, intern,     model,            schema) \
    i_prop    (X,Y, public,     bool,             finalized) \
    i_prop    (X,Y, intern,     model,            init_top) \
    i_prop    (X,Y, public,     emember,          mem_init) \
    i_method  (X,Y, public,     emember,          member_lookup, string, AType) \
    i_method  (X,Y, public,     model,            typed) \
    s_method  (X,Y, public,     string,           keyword) \
    i_method  (X,Y, public,     model,            pointer,       string) \
    i_final   (X,Y, public,     none,             finalize) \
    i_method  (X,Y, public,     emember,          convertible,   model) \
    i_method  (X,Y, public,     emember,          castable,      model) \
    i_method  (X,Y, public,     emember,          constructable, model) \
    i_override(X,Y, cast,       string) \
    i_override(X,Y, method,     init)
declare_class(model)

// some models are simple sub-classes to indicate their use
// use members on model for args
#define eargs_schema(X,Y,...) \
    i_prop(X,Y, public, bool, is_ext) \
    i_override(X,Y, method, init)
declare_class_2(eargs, model)


#define format_attr_schema(X,Y,...) \
    i_prop(X,Y, required, string, type) \
    i_prop(X,Y, public,   i32,    format_index) \
    i_prop(X,Y, public,   i32,    arg_index)
declare_class(format_attr)


#define fn_schema(X,Y,...) \
    i_prop(X,Y, public,     bool,                   is_cast) \
    i_prop(X,Y, public,     bool,                   is_ctr) \
    i_prop(X,Y, public,     bool,                   is_idx) \
    i_prop(X,Y, public,     OPType,                 is_oper) \
    i_prop(X,Y, public,     bool,                   is_module_init) \
    i_prop(X,Y, public,     bool,                   is_override) \
    i_prop(X,Y, public,     bool,                   is_ifinal) \
    i_prop(X,Y, public,     bool,                   is_global_ctr) \
    i_prop(X,Y, public,     bool,                   va_args) \
    i_prop(X,Y, public,     model,                  rtype) \
    i_prop(X,Y, public,     eargs,                  args) \
    i_prop(X,Y, public,     record,                 payload) \
    i_prop(X,Y, public,     bool,                   exported) \
    i_prop(X,Y, public,     model,                  instance) \
    i_prop(X,Y, public,     bool,                   single_expr) \
    i_prop(X,Y, public,     emember,                target) \
    i_prop(X,Y, public,     emember,                main_member) \
    i_prop(X,Y, public,     AFlag,                  function_type) \
    i_prop(X,Y, intern,     format_attr,            format) \
    i_prop(X,Y, intern,     LLVMMetadataRef,        last_dbg,  as, ARef) \
    i_prop(X,Y, intern,     LLVMBasicBlockRef,      entry,     as, ARef) \
    i_prop(X,Y, intern,     LLVMValueRef,           value,     as, ARef) \
    i_prop(X,Y, intern,     LLVMTypeRef*,           arg_types, as, ARef) \
    i_prop(X,Y, intern,     num,                    arg_count) \
    i_method(X,Y, public,   none,                   use) \
    i_override(X,Y, method, init)
declare_class_2(fn, model)


#define clang_cc_schema(X,Y,...) \
    i_prop  (X,Y, public, aether,   mod) \
    i_prop  (X,Y, public, handle,   compiler) \
    i_prop  (X,Y, public, handle,   PP)
declare_class(clang_cc)

#define macro_schema(X,Y,...) \
    i_prop  (X,Y, public, array,    params) \
    i_prop  (X,Y, public, clang_cc, instance) \
    i_prop  (X,Y, public, string,   definition) \
    i_prop  (X,Y, public, bool,     is_var) \
    i_method(X,Y, public, array,    expand, array)
declare_class_2(macro, model)


#define statements_schema(X,Y,...) \
    i_override(X,Y, method, init)
declare_class_2(statements, model)

typedef struct _schematic* schematic;
 
// for each field, f_* name-bound class, enum or primitive
#define record_schema(X,Y,...) \
    i_prop    (X,Y, public, record, parent) \
    i_prop    (X,Y, public, array,  meta) \
    i_prop    (X,Y, public, bool,   parsing) \
    i_prop    (X,Y, public, bool,   is_abstract) \
    i_prop    (X,Y, public, i32,    total_members) \
    i_prop    (X,Y, public, bool,   expect_members) \
    i_override(X,Y, method,         init)
declare_class_2(record, model)

#define Class_schema(X,Y,...)
declare_class_3(Class, record, model)

#define structure_schema(X,Y,...)
declare_class_3(structure, record, model)

#define enumeration_schema(X,Y,...) \
    i_prop    (X,Y, public, model, vtype) \
    i_prop    (X,Y, public, map,   global_values) \
    i_override(X,Y, method, init)
declare_class_2(enumeration, model)

#define uni_schema(X,Y,...)
declare_class_3(uni, record, model)


/// the base helps us require the two args we need for nodes
/// we are also coupling type along inside enode, and this must be set properly with value macro
/// all enode values must contain its aether def.
/// otherwise we are performing hash lookups, which is more complex and slower, 
/// with less data stored
forward(emember)

#define enode_schema(X,Y,...)\
    i_prop    (X,Y, public,     token,                  name) \
    i_prop    (X,Y, public,     aether,                 mod) \
    i_prop    (X,Y, required,   model,                  mdl) \
    i_prop    (X,Y, public,     A,                      literal) \
    i_prop    (X,Y, public,     num,                    line) \
    i_prop    (X,Y, public,     num,                    column) \
    i_prop    (X,Y, public,     bool,                   loaded) \
    i_prop    (X,Y, intern,     LLVMValueRef,           value, as, ARef) \
    i_method  (X,Y, public,     emember,  resolve,      string)
declare_class(enode)


// if ref is set, its a reference to a member with type definition (model, struct, ref)
#define emember_schema(X,Y,...) \
    i_prop    (X,Y, public,     interface,              access) \
    i_prop    (X,Y, public,     array,                  aliases, meta, string) \
    i_prop    (X,Y, public,     model,                  context, meta, weak) \
    i_prop    (X,Y, public,     array,                  meta_args) \
    i_prop    (X,Y, public,     emember,                target_member) \
    i_prop    (X,Y, public,     record,                 target_record) \
    i_prop    (X,Y, public,     bool,                   registered) \
    i_prop    (X,Y, public,     aether,                 is_module) \
    i_prop    (X,Y, public,     bool,                   is_static) \
    i_prop    (X,Y, public,     bool,                   is_require) \
    i_prop    (X,Y, public,     bool,                   is_inlay) \
    i_prop    (X,Y, public,     bool,                   is_const) \
    i_prop    (X,Y, public,     bool,                   is_assigned) \
    i_prop    (X,Y, public,     bool,                   is_type) \
    i_prop    (X,Y, public,     bool,                   is_func) \
    i_prop    (X,Y, public,     bool,                   is_macro) \
    i_prop    (X,Y, public,     bool,                   is_arg) \
    i_prop    (X,Y, public,     bool,                   is_decl) \
    i_prop    (X,Y, public,     A,                      override_offset_bits) \
    i_prop    (X,Y, public,     A,                      override_size_bits) \
    i_prop    (X,Y, public,     A,                      override_alignment_bits) \
    i_prop    (X,Y, public,     path,                   imported_from) \
    i_prop    (X,Y, public,     A,                      initializer) \
    i_prop    (X,Y, intern,     i32,                    offset_bits) \
    i_prop    (X,Y, intern,     i32,                    index) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        debug, as, ARef) \
    i_method  (X,Y, public,     none,    release) \
    i_method  (X,Y, public,     bool,    has_value) \
    i_method  (X,Y, public,     none,    set_model,     model) \
    i_method  (X,Y, public,     none,    set_value,     A) \
    i_override(X,Y, method,     init)
declare_class_2(emember, enode)


#define code_schema(X,Y,...) \
    i_prop    (X,Y, intern, LLVMBasicBlockRef, block, as, ARef) \
    i_prop    (X,Y, public, aether,  mod) \
    i_prop    (X,Y, public, symbol, label) \
    i_method  (X,Y, public, none,   seek_end) \
    i_override(X,Y, method, init)
declare_class(code)

#define ident_schema(X,Y,...) \
    i_prop(X,Y, public, model, mdl) \
    i_ctr(X,Y, public, model)
declare_class(ident)

#define aether_schema(X,Y,...)\
    i_prop    (X,Y, public,     path,        install) \
    i_prop    (X,Y, required,   path,        source) \
    i_prop    (X,Y, public,     array,       lib_paths) \
    i_prop    (X,Y, public,     array,       include_paths) \
    i_prop    (X,Y, intern,     array,       shared_libs) \
    i_prop    (X,Y, public,     bool,        delegate) \
    i_prop    (X,Y, public,     bool,        with_debug) \
    i_prop    (X,Y, intern,     bool,        is_A_import) \
    i_prop    (X,Y, intern,     path,        current_include) \
    i_prop    (X,Y, intern,     fn,          current_fn) \
    i_prop    (X,Y, public,     bool,        in_ref) \
    i_prop    (X,Y, public,     model,       top) \
    i_prop    (X,Y, public,     array,       lex) \
    i_prop    (X,Y, public,     hook,        parse_f) \
    i_prop    (X,Y, public,     map,         base) \
    i_prop    (X,Y, public,     enode,       last_return) \
    i_prop    (X,Y, intern,     array,       finalizing) \
    i_prop    (X,Y, intern,     LLVMExecutionEngineRef, jit,               as, ARef) \
    i_prop    (X,Y, intern,     LLVMBasicBlockRef,      current_if_block,  as, ARef) \
    i_prop    (X,Y, intern,     LLVMModuleRef,          module,            as, ARef) \
    i_prop    (X,Y, intern,     LLVMContextRef,         module_ctx,        as, ARef) \
    i_prop    (X,Y, intern,     LLVMBuilderRef,         builder,           as, ARef) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        file,              as, ARef) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        compile_unit,      as, ARef) \
    i_prop    (X,Y, intern,     LLVMDIBuilderRef,       dbg_builder,       as, ARef) \
    i_prop    (X,Y, intern,     LLVMTargetRef,          target,            as, ARef) \
    i_prop    (X,Y, intern,     LLVMTargetDataRef,      target_data,       as, ARef) \
    i_prop    (X,Y, intern,     LLVMTargetMachineRef,   target_machine,    as, ARef) \
    i_prop    (X,Y, intern,     cstr,        target_triple) \
    i_prop    (X,Y, public,     bool,        left_hand) \
    i_prop    (X,Y, public,     array,       tokens) \
    i_prop    (X,Y, public,     array,       stack) \
    i_prop    (X,Y, public,     num,         cursor) \
    i_prop    (X,Y, public,     map,         instances) \
    i_method  (X,Y, public,     array,       classes,            model, model, bool) \
    i_method  (X,Y, public,     array,       fields,             model, model, bool) \
    i_method  (X,Y, public,     none,        update_schemas) \
    i_method  (X,Y, public,     emember,     initializer) \
    i_method  (X,Y, public,     path,        lookup_include,     string) \
    i_method  (X,Y, public,     none,        build_info,         path) \
    i_method  (X,Y, public,     none,        A_import,           path) \
    i_method  (X,Y, public,     none,        push_state,         array, num) \
    i_method  (X,Y, public,     none,        push_current) \
    i_method  (X,Y, public,     none,        pop_state,          bool) \
    i_method  (X,Y, public,     enode,       e_fn_return,        A) \
    i_method  (X,Y, public,     enode,       e_default_value,    model) \
    i_method  (X,Y, public,     enode,       e_builder,          subprocedure) \
    i_method  (X,Y, public,     none,        build_initializer,  fn) \
    i_method  (X,Y, public,     enode,       e_element,          enode,      A) \
    i_method  (X,Y, public,     none,        e_cmp_code,         enode,      comparison, enode, code, code) \
    i_method  (X,Y, public,     none,        e_branch,           code) \
    i_method  (X,Y, public,     emember,     compatible,         record,     string, AFlag, array) \
    i_method  (X,Y, public,     none,        register_member,    emember) \
    i_method  (X,Y, public,     emember,     register_model,     model) \
    i_method  (X,Y, public,     enode,       e_operand,          A,          model) \
    i_method  (X,Y, public,     enode,       e_op,               OPType,     string, A, A) \
    i_method  (X,Y, public,     enode,       e_load,             emember, emember) \
    i_method  (X,Y, public,     enode,       e_typeid,           model) \
    i_method  (X,Y, public,     enode,       e_offset,           enode,      A) \
    i_method  (X,Y, public,     enode,       e_if_else,          array,      array, subprocedure, subprocedure) \
    i_method  (X,Y, public,     enode,       e_ternary,          enode,      enode, enode) \
    i_method  (X,Y, public,     enode,       e_convert,          enode,      model) \
    i_method  (X,Y, public,     enode,       e_addr_of,          enode,      model) \
    i_method  (X,Y, public,     enode,       e_bitwise_not,      enode) \
    i_method  (X,Y, public,     enode,       e_not,              enode) \
    i_method  (X,Y, public,     none,        e_inc,              enode,      num) \
    i_method  (X,Y, public,     none,        e_print_node,       enode) \
    i_method  (X,Y, public,     emember,     e_var,              model,      string) \
    i_method  (X,Y, public,     enode,       e_or,               A,          A) \
    i_method  (X,Y, public,     enode,       e_xor,              A,          A) \
    i_method  (X,Y, public,     enode,       e_and,              A,          A) \
    i_method  (X,Y, public,     enode,       e_add,              A,          A) \
    i_method  (X,Y, public,     enode,       e_sub,              A,          A) \
    i_method  (X,Y, public,     enode,       e_mul,              A,          A) \
    i_method  (X,Y, public,     enode,       e_div,              A,          A) \
    i_method  (X,Y, public,     enode,       e_create,             model,      A) \
    i_method  (X,Y, public,     enode,       e_zero,               enode) \
    i_method  (X,Y, public,     enode,       e_assign,             enode,      A, OPType) \
    i_method  (X,Y, public,     enode,       e_eq,                 enode,      enode) \
    i_method  (X,Y, public,     enode,       e_cmp,                enode,      enode) \
    i_method  (X,Y, public,     enode,       e_not_eq,             enode,      enode) \
    i_method  (X,Y, public,     enode,       e_fn_call,            emember,    array) \
    i_method  (X,Y, public,     enode,       e_is,               enode,      A) \
    i_method  (X,Y, public,     enode,       e_inherits,         enode,      A) \
    i_method  (X,Y, public,     emember,     lookup2,            A,          AType) \
    i_method  (X,Y, public,     emember,     find_member,        string,     record, AType) \
    i_method  (X,Y, public,     model,       context_model,      AType) \
    i_method  (X,Y, public,     path,        include,            A, ARef) \
    i_method  (X,Y, public,     none,        llflag,             symbol,     i32) \
    i_method  (X,Y, public,     model,       push,               model) \
    i_method  (X,Y, public,     model,       pop) \
    i_method  (X,Y, public,     model,       top) \
    i_method  (X,Y, public,     bool,        emit,           ARef,       ARef) \
    i_method  (X,Y, public,     model,       return_type) \
    i_override(X,Y, method,     init) \
    i_override(X,Y, method,     dealloc)
declare_class_2(aether, model)

// i_vargs   (X,Y, public,     none,       eprint,         symbol) \

bool is_void     (model);
bool is_bool     (model);
bool is_float    (model);
bool is_double   (model);
bool is_realistic(model);
bool is_integral (model);
bool is_signed   (model);
bool is_unsigned (model);
bool is_record   (model);
bool is_generic  (model);
bool is_class    (model);
bool is_enumeration(model);
bool is_struct   (model);
bool is_ref      (model);

#endif