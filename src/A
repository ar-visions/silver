#ifndef _A_
#define _A_

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#ifndef _WIN32
#include <libgen.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#endif
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950288
#endif

#define forward(t) typedef struct _##t* t;

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _AType *AType;

struct _array;
struct _AType;

#define a(...) array_of(__VA_ARGS__ __VA_OPT__(,) null)
#define m(...)   map_of(__VA_ARGS__ __VA_OPT__(,) null)

#define len(I,...) ({ __typeof__(I) _i_ = I; _i_ ? (num)ftableI(_i_)->len(_i_, ## __VA_ARGS__) : (num)0; })


#define true                (bool)1
#define false               (bool)0
#define stringify(x)               stringify_actual(x)
#define stringify_actual(x)        #x
#ifdef __cplusplus
#define null                nullptr
#else
#define null                ((void*)0)
#endif
#define FNV_PRIME           0x100000001b3
#define OFFSET_BASIS        0xcbf29ce484222325

/// A-type runtime
typedef void                    none;
typedef signed char             i8;
typedef short                   i16;
typedef int                     i32;
typedef long long               i64;
typedef unsigned char           u8;
typedef unsigned short          u16;
typedef unsigned int            u32;
typedef unsigned long long      u64;

typedef u64                     AF;
typedef long long               num;
typedef long long               sz;      /// a signed 64 bit size lets us act like python, so this is a type for the purpose of indexing and all valid sizes
#ifndef __cplusplus
typedef u8                      bool;
#endif
typedef float                   f32;
typedef double                  f64;
typedef double                  real;    /// real enough
typedef void*                   handle;
typedef char*                   cstr;
typedef const char*             symbol;
typedef bool                   *ref_bool;

typedef struct cereal { char* value; } cereal;

// typedef struct _object*         A;
typedef struct _A**             ARef; /// registered for a generic raw, but we must transition to use 'raw' in cases where they are not A-allocations
typedef float*                  floats;
typedef cstr*                   cstrs;
typedef void*                   raw;        // abstract types are void*
typedef void*                   numeric;


#include <object.h>

#undef assert
#include <macros.h>

typedef signed char            *ref_i8;
typedef short                  *ref_i16;
typedef int                    *ref_i32;
typedef long long              *ref_i64;
typedef unsigned char          *ref_u8;
typedef unsigned short         *ref_u16;
typedef unsigned int           *ref_u32;
typedef unsigned long long     *ref_u64;
typedef float                  *ref_f32;
typedef double                 *ref_f64;

#define A_f_members(B) \
    AType           parent_type; \
    char*           name; \
    char*           module; \
    AType*          sub_types; \
    i16             sub_types_count; \
    i16             sub_types_alloc; \
    int             size; \
    int             isize; \
    af_recycler     af; \
    int             magic; \
    int             global_count; \
    int             vmember_count; \
    AType           vmember_type; \
    int             member_count; \
    member          members; \
    int             traits; \
    void*           user; \
    u64             required[2]; \
    AType           src; \
    void*           arb; \
    struct _shape*  shape; \
    _meta_t         meta; \

#define declare_typedef(X) \
    typedef struct _ ## X* X;

#define decl_type(AA) \
    typedef struct _##AA##_info { \
        struct _A     info; \
        AA##_f        type; \
    } AA##_info; \
    extern AA##_info   AA##_i; \

#define declare_base( AA ) \
    declare_typedef(AA) \
    _Pragma("pack(push, 1)") \
    struct AA ## _fields { \
        u8 __none__; \
    }; \
    typedef struct _ ## AA { \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        AA##_intern_footer (AA) \
        struct _##AA##_f* f; \
        struct _##AA##_f* f2; \
    } *AA; \
    AA##_schema (AA, DECL) \
    typedef struct _##AA##_f { \
        A_f_members(A) \
        AA##_schema (AA, METHOD) \
    } AA##_f; \
    typedef struct _##AA##Type_info { \
        struct _A     info; \
        struct _##AA##Type_ { \
            A_f_members(A) \
        } type; \
    } AA##Type_info; \
    extern AA##Type_info   AA##Type_i; \
    decl_type(AA) \
    _Pragma("pack(pop)")

// a void* is abstract enough
#define declare_abstract( X, ... ) \
    _Pragma("pack(push, 1)") \
    typedef void* X; \
    typedef struct _##X##_f { \
        A_f_members(A) \
        A_schema(A, METHOD) \
        X##_schema(X, METHOD, __VA_ARGS__) \
    } X##_f, *X##_ft; \
    decl_type(X) \
    _Pragma("pack(pop)") \


#define declare_primitive( AA, Y, ... ) \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA##_f { \
        A_f_members(A) \
        A_schema(A, METHOD, __VA_ARGS__) \
        AA##_schema(AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define ENUM_COUNT(...)  (sizeof((int[]){__VA_ARGS__}) / sizeof(int))

// can technically use enums to phone home with real numbers
#define declare_typed_enum( E, T ) \
    typedef T E; \
    E##_schema(E, T, DECL) \
    _Pragma("pack(push, 1)") \
    typedef struct _##E##_f { \
        A_f_members(A) \
        A_schema   (A, METHOD) \
        E##_schema (A, T, METHOD) \
    } E##_f, *E##_ft; \
    static const i32 E##_ENUM_COUNT = ENUM_COUNT(E##_schema(E, T, COUNT)); \
    decl_type(E)\
    _Pragma("pack(pop)") \

#define declare_enum( E ) declare_typed_enum(E, i32)

void lazy_init(global_init_fn fn);

#define define_typed_enum( E, T ) \
    E##_info E##_i;\
    static __attribute__((constructor)) bool global_##E() { \
        E ## _i.info.type = (AType)&E ## _i.type; \
        E ## _i.info.refs = 1000; \
        E ## _f* type_ref = &E ## _i.type; \
        A_f* base_ref   = &A_i.type; \
        if ((AType)type_ref != (AType)base_ref && base_ref->size == 0) { \
            lazy_init((global_init_fn)&global_##E); \
            return false; \
        } else { \
            memcpy(type_ref, base_ref, sizeof(struct _AType)); \
            static struct _member members[64 + ENUM_COUNT(E##_schema(E, T, COUNT)) + sizeof(E##_i.type) / sizeof(void*)]; \
            memset(type_ref, 0, sizeof(E##_i.type)); \
            type_ref->magic = 1337; \
            type_ref->src      = typeid(T); \
            type_ref->parent_type = (__typeof__(E##_i.type.parent_type))& A_i.type; \
            type_ref->name     = #E;                 \
            type_ref->module   = MODULE;             \
            type_ref->size     = sizeof(E);          \
            type_ref->members  = members;            \
            type_ref->member_count = 0;              \
            type_ref->traits   = A_TRAIT_ENUM;       \
            type_ref->arb      = primitive_ffi_arb(typeid(i32)); \
            E##_schema( E, T, IMPL ); \
            push_type(type_ref); \
            return true; \
        } \
    }

#define define_enum( E ) \
    define_typed_enum(E, i32)

#define FIELD_ID(TYPE, MEMBER) offsetof(struct TYPE##_fields, MEMBER)

#define declare_class\
(AA, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        AA##_intern (AA, F, __VA_ARGS__) \
    }; \
    typedef struct _##AA { \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        AA##_intern_footer (AA) \
        struct _##AA##_f* f; \
        struct _##AA##_f* f2; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        A_f_members(AA) \
        A_schema(AA, METHOD, __VA_ARGS__) \
        AA##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")


#define declare_class_2\
(AA, BB, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
    }; \
    typedef struct _##AA { \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        BB##_intern_footer (BB) \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        AA##_intern_footer (AA) \
        struct _##AA##_f* f; \
        struct _##AA##_f* f2; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        A_f_members(AA) \
        A_schema(AA, METHOD, __VA_ARGS__) \
        BB##_schema (BB, METHOD, __VA_ARGS__) \
        AA##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define declare_class_3\
(AA, BB, CC, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        CC##_intern (CC, F, __VA_ARGS__) \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
    }; \
    typedef struct _##AA { \
        CC##_intern (CC, INST_U, __VA_ARGS__) \
        CC##_intern (CC, INST_L, __VA_ARGS__) \
        CC##_intern_footer (CC) \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        BB##_intern_footer (BB) \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        AA##_intern_footer (AA) \
        struct _##AA##_f* f; \
        struct _##AA##_f* f2; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        A_f_members(AA) \
        A_schema(AA, METHOD, __VA_ARGS__) \
        CC##_schema (CC, METHOD, __VA_ARGS__) \
        BB##_schema (BB, METHOD, __VA_ARGS__) \
        AA##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")


#define declare_class_4\
(AA, BB, CC, DD, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    struct AA##_fields { \
        DD##_intern (DD, F, __VA_ARGS__) \
        CC##_intern (CC, F, __VA_ARGS__) \
        BB##_intern (BB, F, __VA_ARGS__) \
        AA##_intern (AA, F, __VA_ARGS__) \
    }; \
    typedef struct _##AA { \
        DD##_intern (DD, INST_U, __VA_ARGS__) \
        DD##_intern (DD, INST_L, __VA_ARGS__) \
        DD##_intern_footer (DD) \
        CC##_intern (CC, INST_U, __VA_ARGS__) \
        CC##_intern (CC, INST_L, __VA_ARGS__) \
        CC##_intern_footer (CC) \
        BB##_intern (BB, INST_U, __VA_ARGS__) \
        BB##_intern (BB, INST_L, __VA_ARGS__) \
        BB##_intern_footer (BB) \
        AA##_intern (AA, INST_U, __VA_ARGS__) \
        AA##_intern (AA, INST_L, __VA_ARGS__) \
        AA##_intern_footer (AA) \
        struct _##AA##_f* f; \
        struct _##AA##_f* f2; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        A_f_members(AA) \
        A_schema(AA, METHOD, __VA_ARGS__) \
        DD##_schema (DD, METHOD, __VA_ARGS__) \
        CC##_schema (CC, METHOD, __VA_ARGS__) \
        BB##_schema (BB, METHOD, __VA_ARGS__) \
        AA##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define arg_count_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define arg_count(...) arg_count_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define declare_base_meta\
(AA, BASE, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        BASE##_intern (AA, INST, __VA_ARGS__) \
        struct _##AA##_f* f; \
        struct _##AA##_f* f2; \
    } *AA; \
    typedef struct _##AA##_f { \
        A_f_members(BASE) \
        BASE##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define declare_struct\
(AA,...) \
    typedef struct _##AA AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        AA##_schema (AA, INST, __VA_ARGS__) \
    } AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        A_f_members(AA) \
        AA##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    decl_type(AA)\
    _Pragma("pack(pop)")

#define module_init(fn) \
    static bool _module_init() { \
        fn(); \
        return true; \
    } \
    static __attribute__((constructor)) void _module_register() { \
        A_register_init((global_init_fn)&_module_init); \
    }


void* primitive_ffi_arb(AType);

#ifndef NDEBUG
#define IS_DEBUG 0
#else
#define IS_DEBUG 1
#endif


/// alias lets use tag types with an array of types, enabling 
/// design-time and runtime template-like functionality, with 
/// permutation of the class-type and instance-type
#define define_arb(TYPE, BASE, TYPE_SZ, TRAIT, VMEMBER_COUNT, VMEMBER_TYPE, POST_PUSH, ...) \
    _Pragma("pack(push, 1)") \
    __thread struct _af_recycler TYPE##_af; \
    TYPE##_info TYPE##_i; \
    _Pragma("pack(pop)") \
    static __attribute__((constructor)) bool Aglobal_##TYPE() { \
        TYPE##_f* type_ref = &TYPE##_i.type; \
        BASE##_f* base_ref = &BASE##_i.type; \
        if (!AType_i.type.name) { \
            AType_i.type.name   = "AType"; \
            AType_i.type.traits = A_TRAIT_BASE; \
            AType_i.type.src    = typeid(A); \
        } \
        int validate_count = 0; \
        char* member_validate[256] = {}; \
        if ((AType)type_ref == (AType)base_ref) \
            type_ref->name = #TYPE; \
        if ((AType)type_ref != (AType)base_ref && (!base_ref->traits)) { \
            lazy_init((global_init_fn)&Aglobal_##TYPE); \
            return false; \
        } else { \
            printf("global ctr for %s\n", #TYPE); \
            fflush(stdout); \
            memset(type_ref, 0,        sizeof(TYPE##_f)); \
            if ((AType)type_ref != (AType)base_ref) \
                memcpy(type_ref, base_ref, sizeof(BASE##_f)); \
            type_ref->af = &TYPE##_af; \
            type_ref->af->re_alloc = 1024; \
            type_ref->af->re = (object*)(A*)calloc(1024, sizeof(A)); \
            type_ref->isize = 0 TYPE##_schema( TYPE, ISIZE, __VA_ARGS__ ); \
            type_ref->magic = 1337; \
            static struct _member members[512]; \
            type_ref->src = (AType)base_ref != typeid(A) \
                 ? (AType)base_ref : (AType)null; \
            type_ref->parent_type = \
                (__typeof__(type_ref->parent_type))&BASE##_i.type; \
            type_ref->name          = #TYPE; \
            type_ref->module        = (cstr)MODULE; \
            type_ref->members       = members; \
            type_ref->member_count  = 0; \
            type_ref->size          = TYPE_SZ; \
            type_ref->vmember_count = VMEMBER_COUNT; \
            type_ref->vmember_type  = (AType)VMEMBER_TYPE; \
            type_ref->traits        = TRAIT; \
            type_ref->meta          = (_meta_t) { emit_types(__VA_ARGS__) }; \
            type_ref->arb           = primitive_ffi_arb(typeid(TYPE)); \
            TYPE##_schema( TYPE, INIT, __VA_ARGS__ ) \
            push_type((AType)type_ref); \
            POST_PUSH; \
            return true; \
        } \
    } \


#define define_init(id, ...) \
    static __attribute__((constructor)) none Aglobal_initializer_##id() { \
        __VA_ARGS__; \
    }

// define any class as vectorable; useful for serialization and other things
#define define_vector(t, scalar, count) \
    define_init(t, t##_i.type.vmember_type = typeid(scalar); t##_i.type.vmember_count = count)

#define define_any(A0, A1, SZ, traits, ...) \
    define_arb(A0, A1, SZ, traits, 0, null, ({}), __VA_ARGS__)

#define define_class(A0, A1, ...) \
    define_any(A0, A1, sizeof(struct _##A0), A_TRAIT_CLASS, __VA_ARGS__)

#define define_public(A0, A1, ...) \
    define_any(A0, A1, sizeof(struct _##A0), A_TRAIT_PUBLIC, __VA_ARGS__)

#define define_struct(A0, ...) \
    define_any(A0, A0, sizeof(struct _##A0), A_TRAIT_STRUCT, __VA_ARGS__)

#define define_primitive(A0, A1, traits, ...) \
    define_any(A0, A1, sizeof(A0), traits | A_TRAIT_PRIMITIVE, __VA_ARGS__)

#define define_abstract(A0, traits, ...) \
    define_any(A0, A, 0, traits | A_TRAIT_ABSTRACT, __VA_ARGS__)

struct _sz { i64 value; };

// true utility / internal functions
num             clamp(num i, num mn, num mx);
real            clampf(real, real, real);
i64             epoch_millis();
A          A_initialize(A);
none            A_init_recur(A a, AType current, raw last_init);

/// A-type properties are not user-accessible, 
/// so they are declared as opaque
/// the methods Are, accessible

forward(ctx)
forward(array)
forward(map)
forward(string)
forward(path)
forward(vector)
forward(any)


// A-type must generate defines for sizes for users of it
#define A_schema(AA,Y,...) \
    i_prop  (AA,Y, intern, AType,       type) \
    i_prop  (AA,Y, intern, AType,       scalar) \
    i_prop  (AA,Y, intern, i64,         refs) \
    i_prop  (AA,Y, intern, A,           data) \
    i_prop  (AA,Y, intern, shape,       shape) \
    i_prop  (AA,Y, intern, cstr,        source) \
    i_prop  (AA,Y, intern, i64,         line) \
    i_prop  (AA,Y, intern, i64,         alloc) \
    i_prop  (AA,Y, intern, i64,         count) \
    i_prop  (AA,Y, intern, i64,         recycle) \
    i_prop  (AA,Y, intern, i64,         af_index) \
    i_method(AA,Y, public, none,        init) \
    i_method(AA,Y, public, none,        dealloc) \
    i_method(AA,Y, public, i32,         compare,             AA) \
    i_method(AA,Y, public, u64,         hash) \
    i_method(AA,Y, public, AA,          copy) \
    i_final (AA,Y, public, callback,    bind,                A, bool, AType, AType, symbol, symbol) \
    i_final (AA,Y, public, ref_u64,     AF_bits) \
    i_final (AA,Y, public, none,        AF_set_id,           i32) \
    i_final (AA,Y, public, none,        AF_set_name,         cstr) \
    i_final (AA,Y, public, bool,        AF_query_name,       cstr) \
    i_final (AA,Y, public, A,           instanceof,          AType) \
    i_final (AA,Y, public, AA,          hold) \
    i_final (AA,Y, public, none,        drop) \
    i_final (AA,Y, public, none,        hold_members) \
    i_final (AA,Y, public, none,        drop_members) \
    i_final (AA,Y, public, A,           set_property,        symbol, A) \
    i_final (AA,Y, public, A,           get_property,        symbol) \
    i_final (AA,Y, public, A,           vrealloc,            sz) \
    s_method(AA,Y, public, A,           initialize,          A) \
    i_final (AA,Y, public, A,           member_object,       member) \
    i_final (AA,Y, public, bool,        member_set,          member, A) \
    i_final (AA,Y, public, A,           header) \
    i_final (AA,Y, public, A,           vdata) \
    i_final (AA,Y, public, AType,       vdata_type) \
    i_final (AA,Y, public, i64,         vdata_stride) \
    i_final (AA,Y, public, bool,        is_meta) \
    i_final (AA,Y, public, bool,        is_meta_compatible,  A) \
    t_vargs (AA,Y, public, A,           formatter,           handle, A, symbol) \
    t_method(AA,Y, public, A,           alloc,               num) \
    t_method(AA,Y, public, A,           alloc_dbg,           num,     cstr,      i32) \
    t_method(AA,Y, public, A,           alloc2,              AType,   shape) \
    t_method(AA,Y, public, string,      estring,             i32) \
    t_method(AA,Y, public, i32,         evalue,              cstr) \
    t_method(AA,Y, public, none,        serialize,           string,  A) \
    t_method(AA,Y, public, A,           convert,             A) \
    t_method(AA,Y, public, bool,        inherits,            AType) \
    t_method(AA,Y, public, A,           construct_with,      A,         ctx) \
    t_method(AA,Y, public, bool,        constructs_with,     AType) \
    t_method(AA,Y, public, member,      find_ctr,            AType, bool) \
    t_method(AA,Y, public, member,      find_member,         AFlag, symbol,    bool) \
    t_method(AA,Y, public, member,      member_first,        AType, bool) \
    t_method(AA,Y, public, member,      member_type,         AFlag, AType,     bool) \
    t_method(AA,Y, public, A,           primitive,           raw) \
    t_method(AA,Y, public, A,           method,              cstr,    array) \
    t_method(AA,Y, public, A,           parse,               cstr, ctx) \
    t_method(AA,Y, public, i32,         alloc_count) \
    t_method(AA,Y, public, none,        push_type) \
    t_method(AA,Y, public, A,           typecast,            A) \
    s_method(AA,Y, public, none,        member_override,     AType, member, AFlag) \
    s_method(AA,Y, public, none,        register_init,       func) \
    s_method(AA,Y, public, bool,        is_inlay,            member) \
    s_method(AA,Y, public, AType,       find_type,           symbol) \
    s_method(AA,Y, public, map,         arguments,           i32, cstrs, map, A) \
    s_method(AA,Y, public, ARef,        types,               ref_i64) \
    s_method(AA,Y, public, none,        tap,                 symbol, hook) \
    s_method(AA,Y, public, none,        untap,               symbol) \
    s_method(AA,Y, public, none,        recycle) \
    s_method(AA,Y, public, none,        engage,              cstrs) \
    s_vargs (AA,Y, public, map,         args,                cstrs, symbol) \
    s_vargs (AA,Y, public, map,         map_of,              symbol) \
    i_ctr   (AA,Y, public, cereal) \
    i_ctr(AA,Y, public, cstrs) \
    i_cast  (AA,Y, public, string) \
    i_cast  (AA,Y, public, bool)

#define A_intern_footer(AA)
                    
#define A_intern(AA,YY,...) A_schema(AA,YY,__VA_ARGS__)

//typedef struct _shape *shape;

declare_base(A)

#define typeid(AA)   ((AType)&AA##_i.type)
#define scalarof(AA) head(AA)->scalar

#define numeric_schema(AA,Y,...) \
    i_operator(AA,Y, public, numeric, _add, numeric) \
    i_operator(AA,Y, public, numeric, _sub, numeric) \
    i_operator(AA,Y, public, numeric, _mul, numeric) \
    i_operator(AA,Y, public, numeric, _div, numeric) \
    i_operator(AA,Y, public, numeric, _or, numeric) \
    i_operator(AA,Y, public, numeric, _and, numeric) \
    i_operator(AA,Y, public, numeric, _xor, numeric) \
    i_operator(AA,Y, public, numeric, _mod, numeric) \
    i_operator(AA,Y, public, numeric, _right, numeric) \
    i_operator(AA,Y, public, numeric, _left,  numeric) \
    i_operator(AA,Y, public, numeric, _compare,   numeric) \
    i_operator(AA,Y, public, numeric, _equal,     numeric) \
    i_operator(AA,Y, public, numeric, _not_equal, numeric) \
    i_operator(AA,Y, public, none,    _assign,    numeric)
declare_abstract(numeric)

#define string_like_schema(X,Y,...)
declare_abstract(string_like)

#define nil_schema(X,Y,...)
declare_abstract(nil)

#define raw_schema(X,Y,...)
declare_abstract(raw)
 
#define ref_schema(X,Y,...)
declare_abstract(ref)

#define imported_schema(X,Y,...)
declare_abstract(imported)

#define ARef_schema(X,Y,...)        ref_schema(X,Y,...)
#define i8_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define i16_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define i32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define i64_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u8_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define u16_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define u64_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define f32_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define f64_schema(X,Y,...)         numeric_schema(numeric,Y,...)

#define ref_i8_schema(X,Y,...)      numeric_schema(numeric,Y,...)
#define ref_i16_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_i32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_i64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u8_schema(X,Y,...)      numeric_schema(numeric,Y,...)
#define ref_u16_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_u64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_f32_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_f64_schema(X,Y,...)     numeric_schema(numeric,Y,...)
#define ref_bool_schema(X,Y,...)    numeric_schema(numeric,Y,...)

#define AFlag_schema(X,Y,...)       numeric_schema(numeric,Y,...)
#define bool_schema(X,Y,...)        numeric_schema(numeric,Y,...)
#define num_schema(X,Y,...)         numeric_schema(numeric,Y,...)
#define sz_schema(X,Y,...)          numeric_schema(numeric,Y,...)
#define cstr_schema(X,Y,...)        string_like_schema(X,Y,...)
#define symbol_schema(X,Y,...)      string_like_schema(X,Y,...)
#define cereal_schema(X,Y,...)      raw_schema(X,Y,...)
#define shape_schema(X,Y,...)       raw_schema(X,Y,...)
#define none_schema(X,Y,...)        nil_schema(X,Y,...)
#define raw_t_schema(X,Y,...)       raw_schema(X,Y,...)
#define handle_schema(X,Y,...)      raw_schema(X,Y,...)
#define AType_schema(X,Y,...)       raw_schema(X,Y,...)
#define member_schema(X,Y,...)      raw_schema(X,Y,...)
#define func_schema(X,Y,...)        raw_schema(X,Y,...)
#define hook_schema(X,Y,...)        raw_schema(X,Y,...)
#define callback_schema(X,Y,...)    raw_schema(X,Y,...)
#define cstrs_schema(X,Y,...)       raw_schema(X,Y,...)
#define floats_schema(X,Y,...)      raw_schema(X,Y,...)


shape shape_with_array(shape a, array dims);
i64 shape_total(shape a);
i64 shape_compare(shape a, shape b);
shape shape_from(i64 count, i64* values);
shape shape_read(FILE* f);
shape shape_new(i64 size, ...);


/// meta gives us access to one token we can override with (F)

static inline bool AF_get(u64* f, u32 bit_index) {
    if (bit_index < 64) {
        return (f[0] & (((u64)1) << bit_index)) != 0;
    } else {
        return (f[1] & (((u64)1) << (bit_index - 64))) != 0;
    }
}

#define AF_set(f, bit_index) ({ \
    if (bit_index < 64) { \
        ((u64*)f)[0] |= ((u64)1) << bit_index; \
    } else { \
        ((u64*)f)[1] |= ((u64)1) << (bit_index - 64); \
    } \
})

/*
static inline void AF_set(u64* f, u32 bit_index) {
    if (bit_index < 64) {
        f[0] |= ((u64)1) << bit_index;
    } else {
        f[1] |= ((u64)1) << (bit_index - 64);
    }
}
*/

declare_primitive(ref_i8,           numeric)
declare_primitive(ref_i16,          numeric)
declare_primitive(ref_i32,          numeric)
declare_primitive(ref_i64,          numeric)
declare_primitive(ref_u8,           numeric)
declare_primitive(ref_u16,          numeric)
declare_primitive(ref_u32,          numeric)
declare_primitive(ref_u64,          numeric)
declare_primitive(ref_f32,          numeric)
declare_primitive(ref_f64,          numeric)
declare_primitive(ref_bool,         numeric)

declare_primitive( i8,              numeric)
declare_primitive(i16,              numeric)
declare_primitive(i32,              numeric)
declare_primitive(i64,              numeric)
declare_primitive( u8,              numeric)
declare_primitive(u16,              numeric)
declare_primitive(u32,              numeric)
declare_primitive(u64,              numeric)
declare_primitive(f32,              numeric)
declare_primitive(f64,              numeric)
declare_primitive(AFlag,            numeric)
declare_primitive(bool,             numeric)
declare_primitive(num,              numeric)
declare_primitive(sz,               numeric)
declare_primitive(cstr,             string_like)
declare_primitive(symbol,           string_like)
declare_primitive(none,             nil)
declare_primitive(cereal,           raw)
declare_primitive(shape,            raw)
declare_primitive(raw_t,            raw)
declare_primitive(handle,           raw)
declare_primitive(func,             raw)
declare_primitive(hook,             raw)
declare_primitive(callback,         raw)
declare_primitive(cstrs,            raw)

/// whatever we can 'name', we can handle as a type of any pointer primitive
//declare_primitive(AType,        raw)
declare_primitive(ARef,         ref)
declare_primitive(member,       raw)
declare_primitive(floats,       raw)

/// doubly-linked item type, integrated key so we dont also need a 'field' type
#define item_schema(X,Y,...) \
    i_prop    (X,Y, opaque, X,         next) \
    i_prop    (X,Y, opaque, X,         prev) \
    i_prop    (X,Y, opaque, A,    ref) \
    i_prop    (X,Y, opaque, A,    value) \
    i_prop    (X,Y, opaque, A,    key) \
    i_prop    (X,Y, opaque, u64,       h) \
    i_override(X,Y, method, hash) \
    i_override(X,Y, method, init)
declare_class(item)


/// lets mimmick the structure in llama.cpp
#define message_schema(X,Y,...) \
    i_prop(X,Y, public,   cstr, role) \
    i_prop(X,Y, public,   cstr, content) \
    i_override(X,Y, method, init) \
    i_override(X,Y, method, dealloc)
declare_class(message)

/// linked-list of elemental data
#define list_schema(X,Y,...) \
    i_prop  (X,Y, opaque,    item,    first) \
    i_prop  (X,Y, opaque,    item,    last)  \
    i_prop  (X,Y, opaque,    map,     assoc)  \
    i_prop  (X,Y, public,    bool,    unmanaged)  \
    i_prop  (X,Y, public,    i64,     count) \
    i_method(X,Y, public,    A,  pop) \
    i_method(X,Y, public,    item,    push, A) \
    i_method(X,Y, public,    item,    insert_after, A, i32) \
    i_method(X,Y, public,    num,     index_of, A) \
    i_method(X,Y, public,    item,     item_of, A) \
    i_method(X,Y, public,    none,    sort,   ARef) \
    i_method(X,Y, public,    none,    remove, num) \
    i_method(X,Y, public,    none,    remove_item, item) \
    i_method(X,Y, public,    A,  get,  A) \
    i_method(X,Y, public,    num,     count) \
    i_override(X,Y, method, dealloc)
declare_class(list)

/// array of elemental data
/// important to define the same operators here in silver definition of runtime
/// one has arguments (operator) and (cast) does not, thats always instance
/// we need different names for these.  they cannot both be considered 'operators'
/// we also need new data structure, so ops vs casts vs constructs vs methods
// += -= *= /= 
// ":", "+=", "-=", "*=", "/=", "|=",
// "&=", "^=", ">>=", "<<=", "%=", null);

#define OPType_schema(E,T,Y,...) \
    enum_value(E,T,Y, _undefined,         0) \
    enum_value(E,T,Y, _add,               1) \
    enum_value(E,T,Y, _sub,               2) \
    enum_value(E,T,Y, _mul,               3) \
    enum_value(E,T,Y, _div,               4) \
    enum_value(E,T,Y, _or,                5) \
    enum_value(E,T,Y, _and,               6) \
    enum_value(E,T,Y, _xor,               7) \
    enum_value(E,T,Y, _mod,               8) \
    enum_value(E,T,Y, _right,             9) \
    enum_value(E,T,Y, _left,              10) \
    enum_value(E,T,Y, _compare,           11) \
    enum_value(E,T,Y, _equal,             12) \
    enum_value(E,T,Y, _not_equal,         13) \
    enum_value(E,T,Y, _is,                14) \
    enum_value(E,T,Y, _inherits,          15) \
    enum_value(E,T,Y, _value_default,     16) \
    enum_value(E,T,Y, _cond_value,        17) \
    enum_value(E,T,Y, _assign,            18) \
    enum_value(E,T,Y, _assign_add,        19) \
    enum_value(E,T,Y, _assign_sub,        20) \
    enum_value(E,T,Y, _assign_mul,        21) \
    enum_value(E,T,Y, _assign_div,        22) \
    enum_value(E,T,Y, _assign_or,         23) \
    enum_value(E,T,Y, _assign_and,        24) \
    enum_value(E,T,Y, _assign_xor,        25) \
    enum_value(E,T,Y, _assign_mod,        26) \
    enum_value(E,T,Y, _assign_right,      27) \
    enum_value(E,T,Y, _assign_left,       28)
declare_enum(OPType)


#define Key_schema(EE,TT,YY) \
    enum_value_v(EE, TT, YY, Undefined,      0) \
    enum_value_v(EE, TT, YY, Space,         32) \
    enum_value_v(EE, TT, YY, Apostrophe,    39) \
    enum_value_v(EE, TT, YY, Comma,         44) \
    enum_value_v(EE, TT, YY, Minus,         45) \
    enum_value_v(EE, TT, YY, Period,        46) \
    enum_value_v(EE, TT, YY, Slash,         47) \
    enum_value_v(EE, TT, YY, K0,            48) \
    enum_value_v(EE, TT, YY, K1,            49) \
    enum_value_v(EE, TT, YY, K2,            50) \
    enum_value_v(EE, TT, YY, K3,            51) \
    enum_value_v(EE, TT, YY, K4,            52) \
    enum_value_v(EE, TT, YY, K5,            53) \
    enum_value_v(EE, TT, YY, K6,            54) \
    enum_value_v(EE, TT, YY, K7,            55) \
    enum_value_v(EE, TT, YY, K8,            56) \
    enum_value_v(EE, TT, YY, K9,            57) \
    enum_value_v(EE, TT, YY, SemiColon,     59) \
    enum_value_v(EE, TT, YY, Equal,         61) \
    enum_value_v(EE, TT, YY, A,             65) \
    enum_value_v(EE, TT, YY, B,             66) \
    enum_value_v(EE, TT, YY, C,             67) \
    enum_value_v(EE, TT, YY, D,             68) \
    enum_value_v(EE, TT, YY, E,             69) \
    enum_value_v(EE, TT, YY, F,             70) \
    enum_value_v(EE, TT, YY, G,             71) \
    enum_value_v(EE, TT, YY, H,             72) \
    enum_value_v(EE, TT, YY, I,             73) \
    enum_value_v(EE, TT, YY, J,             74) \
    enum_value_v(EE, TT, YY, K,             75) \
    enum_value_v(EE, TT, YY, L,             76) \
    enum_value_v(EE, TT, YY, M,             77) \
    enum_value_v(EE, TT, YY, N,             78) \
    enum_value_v(EE, TT, YY, O,             79) \
    enum_value_v(EE, TT, YY, P,             80) \
    enum_value_v(EE, TT, YY, Q,             81) \
    enum_value_v(EE, TT, YY, R,             82) \
    enum_value_v(EE, TT, YY, S,             83) \
    enum_value_v(EE, TT, YY, T,             84) \
    enum_value_v(EE, TT, YY, U,             85) \
    enum_value_v(EE, TT, YY, V,             86) \
    enum_value_v(EE, TT, YY, W,             87) \
    enum_value_v(EE, TT, YY, X,             88) \
    enum_value_v(EE, TT, YY, Y,             89) \
    enum_value_v(EE, TT, YY, Z,             90) \
    enum_value_v(EE, TT, YY, LeftBracket,   91) \
    enum_value_v(EE, TT, YY, BackSlash,     92) \
    enum_value_v(EE, TT, YY, RightBracket,  93) \
    enum_value_v(EE, TT, YY, GraveAccent,   96) \
    enum_value_v(EE, TT, YY, World1,       161) \
    enum_value_v(EE, TT, YY, World2,       162) \
    enum_value_v(EE, TT, YY, Escape,       256) \
    enum_value_v(EE, TT, YY, Enter,        257) \
    enum_value_v(EE, TT, YY, Tab,          258) \
    enum_value_v(EE, TT, YY, Backspace,    259) \
    enum_value_v(EE, TT, YY, Insert,       260) \
    enum_value_v(EE, TT, YY, Delete,       261) \
    enum_value_v(EE, TT, YY, Right,        262) \
    enum_value_v(EE, TT, YY, Left,         263) \
    enum_value_v(EE, TT, YY, Down,         264) \
    enum_value_v(EE, TT, YY, Up,           265) \
    enum_value_v(EE, TT, YY, PageUp,       266) \
    enum_value_v(EE, TT, YY, PageDown,     267) \
    enum_value_v(EE, TT, YY, Home,         268) \
    enum_value_v(EE, TT, YY, End,          269) \
    enum_value_v(EE, TT, YY, CapsLock,     280) \
    enum_value_v(EE, TT, YY, ScrollLock,   281) \
    enum_value_v(EE, TT, YY, NumLock,      282) \
    enum_value_v(EE, TT, YY, PrintScreen,  283) \
    enum_value_v(EE, TT, YY, Pause,        284) \
    enum_value_v(EE, TT, YY, F1,           290) \
    enum_value_v(EE, TT, YY, F2,           291) \
    enum_value_v(EE, TT, YY, F3,           292) \
    enum_value_v(EE, TT, YY, F4,           293) \
    enum_value_v(EE, TT, YY, F5,           294) \
    enum_value_v(EE, TT, YY, F6,           295) \
    enum_value_v(EE, TT, YY, F7,           296) \
    enum_value_v(EE, TT, YY, F8,           297) \
    enum_value_v(EE, TT, YY, F9,           298) \
    enum_value_v(EE, TT, YY, F10,          299) \
    enum_value_v(EE, TT, YY, F11,          300) \
    enum_value_v(EE, TT, YY, F12,          301) \
    enum_value_v(EE, TT, YY, F13,          302) \
    enum_value_v(EE, TT, YY, F14,          303) \
    enum_value_v(EE, TT, YY, F15,          304) \
    enum_value_v(EE, TT, YY, F16,          305) \
    enum_value_v(EE, TT, YY, F17,          306) \
    enum_value_v(EE, TT, YY, F18,          307) \
    enum_value_v(EE, TT, YY, F19,          308) \
    enum_value_v(EE, TT, YY, F20,          309) \
    enum_value_v(EE, TT, YY, F21,          310) \
    enum_value_v(EE, TT, YY, F22,          311) \
    enum_value_v(EE, TT, YY, F23,          312) \
    enum_value_v(EE, TT, YY, F24,          313) \
    enum_value_v(EE, TT, YY, F25,          314) \
    enum_value_v(EE, TT, YY, Kp0,          320) \
    enum_value_v(EE, TT, YY, Kp1,          321) \
    enum_value_v(EE, TT, YY, Kp2,          322) \
    enum_value_v(EE, TT, YY, Kp3,          323) \
    enum_value_v(EE, TT, YY, Kp4,          324) \
    enum_value_v(EE, TT, YY, Kp5,          325) \
    enum_value_v(EE, TT, YY, Kp6,          326) \
    enum_value_v(EE, TT, YY, Kp7,          327) \
    enum_value_v(EE, TT, YY, Kp8,          328) \
    enum_value_v(EE, TT, YY, Kp9,          329) \
    enum_value_v(EE, TT, YY, KpDecimal,    330) \
    enum_value_v(EE, TT, YY, KpDivide,     331) \
    enum_value_v(EE, TT, YY, KpMultiply,   332) \
    enum_value_v(EE, TT, YY, KpSubtract,   333) \
    enum_value_v(EE, TT, YY, KpAdd,        334) \
    enum_value_v(EE, TT, YY, KpEnter,      335) \
    enum_value_v(EE, TT, YY, KpEqual,      336) \
    enum_value_v(EE, TT, YY, LeftShift,    340) \
    enum_value_v(EE, TT, YY, LeftControl,  341) \
    enum_value_v(EE, TT, YY, LeftAlt,      342) \
    enum_value_v(EE, TT, YY, LeftSuper,    343) \
    enum_value_v(EE, TT, YY, RightShift,   344) \
    enum_value_v(EE, TT, YY, RightControl, 345) \
    enum_value_v(EE, TT, YY, RightAlt,     346) \
    enum_value_v(EE, TT, YY, RightSuper,   347) \
    enum_value_v(EE, TT, YY, Menu,         348)
declare_enum(Key)

#define Exists_schema(E,T,Y,...) \
    enum_value(E,T,Y, no,     0) \
    enum_value(E,T,Y, file,   1) \
    enum_value(E,T,Y, dir,    2)
declare_enum(Exists)

forward(array)

#define vector_schema(X,Y,...) \
    i_prop(X,Y, public, num,     alloc) \
    i_prop(X,Y, public, AType,   type) \
    i_prop(X,Y, public, shape,   shape) \
    i_method(X,Y, public, none,    concat, ARef, num) \
    i_method(X,Y, public, ARef,    get,  num) \
    i_method(X,Y, public, none,    set,  num, ARef) \
    i_method(X,Y, public, none,    push, A) \
    i_method(X,Y, public, vector,  slice, num, num) \
    i_method(X,Y, public, A,       resize, sz) \
    i_guard(X,Y, public, sz,      len) \
    i_ctr(X,Y, public, i32) \
    i_ctr(X,Y, public, path) \
    i_override  (X,Y, method, init)
declare_class(vector)


// let us declare our vector with string
// A, user space is simply the cstring

#define subprocedure_schema(X,Y,...) \
    i_prop    (X,Y, required, A, target) \
    i_prop    (X,Y, public,   A, ctx) \
    i_prop    (X,Y, required, handle, addr) \
    i_method  (X,Y, public,   A, invoke, A)
declare_class(subprocedure)

#define subproc(targ, faddr, context) new(subprocedure, target, targ, ctx, context, addr, faddr) 

typedef A(*mix_fn)(A, A, f32);

#define array_schema(X,Y,O,...) \
    i_vprop          (X,Y, public, A,       elements) \
    i_prop           (X,Y, public, bool,    unmanaged) \
    i_prop           (X,Y, public, bool,    assorted) \
    i_prop           (X,Y, opaque, AType,   last_type) \
    i_prop           (X,Y, public, i32,     alloc) \
    i_prop           (X,Y, public, i32,     len) \
    s_vargs          (X,Y, public, array,   array_of,       A) \
    s_vargs          (X,Y, public, array,   array_of_cstr,  cstr) \
    i_method         (X,Y, public, array,   mix, array, f32) \
    i_method         (X,Y, public, A,       first) \
    i_method         (X,Y, public, A,       last) \
    i_method         (X,Y, public, A,       pop) \
    i_method         (X,Y, public, none,    fill,           A) \
    i_method         (X,Y, public, array,   reverse) \
    i_method         (X,Y, public, none,    remove,         num) \
    i_method         (X,Y, public, none,    remove_weak,    num) \
    i_method         (X,Y, public, none,    push,           A) \
    i_method         (X,Y, public, none,    push_vdata,     A, i64) \
    i_method         (X,Y, public, none,    push_weak,      A) \
    i_method         (X,Y, public, none,    clear) \
    i_method         (X,Y, public, none,    concat,         array) \
    i_method         (X,Y, public, A,       get,            num) \
    i_method         (X,Y, public, A,       peek,           num) \
    i_method         (X,Y, public, num,     count) \
    i_guard          (X,Y, public, sz,      len) \
    i_method         (X,Y, public, num,     index_of,       A) \
    i_operator       (X,Y, public, none,    _assign_add,    A) \
    i_operator       (X,Y, public, none,    _assign_sub,    num) \
    i_vargs          (X,Y, public, none,    push_symbols,   cstr) \
    i_vargs          (X,Y, public, none,    push_objects,   A) \
    i_index          (X,Y, public, A,       num) \
    i_ctr            (X,Y, public, i32) \
    i_override       (X,Y, method, init) \
    i_override       (X,Y, method, dealloc) \
    i_override       (X,Y, cast,   bool) \
    i_override       (X,Y, cast,   string)
declare_class(array, any)

Exists A_exists(A);

#define srcfile_schema(X,Y,...) \
    i_prop           (X,Y, public, A, obj) \
    i_ctr            (X,Y, public, A) \
    i_override       (X,Y, cast,   string)
declare_class(srcfile)


#define hashmap_schema(X,Y,...) \
    i_prop      (X,Y, opaque, list,  data) \
    i_prop      (X,Y, public, num,   alloc) \
    i_prop      (X,Y, public, num,   count) \
    i_prop      (X,Y, public, bool,  unmanaged) \
    i_prop      (X,Y, intern, A, item_header) \
    i_method    (X,Y, public, none,  remove, A) \
    i_method    (X,Y, public, none,  set, A, A) \
    i_method    (X,Y, public, A,get, A) \
    i_method    (X,Y, public, item,  fetch, A) \
    i_method    (X,Y, public, item,  lookup, A) \
    i_method    (X,Y, public, bool,  contains, A) \
    i_method    (X,Y, public, none,  clear) \
    i_index     (X,Y, public, A, A) \
    i_override  (X,Y, cast,   string) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, method, dealloc) \
    i_override  (X,Y, cast,   bool)
declare_class(hashmap)

extern int fault_level;

#define level_schema(E,T,Y,...) \
    enum_value(E,T,Y, information, 0) \
    enum_value(E,T,Y, warn,        1) \
    enum_value(E,T,Y, err,         2)
declare_enum(level)

#define map_schema(X,Y,...) \
    i_prop      (X,Y, public,  list,       fifo) \
    i_prop      (X,Y, opaque,  i64,        count) \
    i_prop      (X,Y, public,  i32,        hsize) \
    i_prop      (X,Y, opaque,  item*,      hlist) \
    i_prop      (X,Y, public,  bool,       unmanaged)  \
    i_prop      (X,Y, opaque,  AType,      last_type) \
    i_prop      (X,Y, public,  bool,       assorted)  \
    i_method    (X,Y, public,  none,       set,        A, A) \
    i_method    (X,Y, public,  A,     get,        A) \
    i_method    (X,Y, public,  A,          value_by_index, num) \
    i_method    (X,Y, public,  item,       lookup,     A) \
    i_method    (X,Y, public,  item,       fetch,      A) \
    i_method    (X,Y, public,  none,       rm,         A) \
    i_method    (X,Y, public,  none,       rm_item,    item) \
    i_method    (X,Y, public,  bool,       contains,   A) \
    i_method    (X,Y, public,  none,       concat,     map) \
    i_method    (X,Y, public,  none,       clear) \
    i_guard     (X,Y, public,  sz,         len) \
    i_index     (X,Y, public,  A,     sz) \
    i_index     (X,Y, public,  A,     A) \
    i_ctr       (X,Y, public,  i32) \
    i_override  (X,Y, method,  init) \
    i_override  (X,Y, method,  dealloc) \
    i_override  (X,Y, cast,    string) \
    i_override  (X,Y, cast,    bool)
declare_class(map)

#define ctx_schema(X,Y,...) \
    i_prop(X,Y, public, A, app) \
    i_prop(X,Y, intern, bool,   establishing)
declare_class_2(ctx, map)

#define string_schema(X,Y,...) \
    i_prop    (X,Y,   public, symbol,  chars) \
    i_prop    (X,Y,   public, num,     alloc) \
    i_prop    (X,Y,   public, num,     ref_length) \
    i_prop    (X,Y,   public, num,     len) \
    i_prop    (X,Y,   public, u64,     h) \
    i_method  (X,Y,   public, string,  evaluate, map) \
    i_method  (X,Y,   public, bool,    is_numeric) \
    i_method  (X,Y,   public, i32,     first) \
    i_method  (X,Y,   public, i32,     last) \
    i_method  (X,Y,   public, f64,     real_value) \
    i_guard   (X,Y,   public, sz,      len) \
    i_method  (X,Y,   public, string,  ucase) \
    i_method  (X,Y,   public, string,  lcase) \
    i_method  (X,Y,   public, array,   split, symbol) \
    i_method  (X,Y,   public, string,  escape) \
    i_method  (X,Y,   public, num,     index_of, symbol) \
    i_method  (X,Y,   public, num,     rindex_of, symbol) \
    i_method  (X,Y,   public, none,    append, symbol) \
    i_method  (X,Y,   public, none,    append_count, symbol, i32) \
    i_method  (X,Y,   public, none,    push, u32) \
    i_method  (X,Y,   public, none,    concat, string) \
    i_method  (X,Y,   public, string,  trim) \
    i_method  (X,Y,   public, string,  ltrim) \
    i_method  (X,Y,   public, string,  rtrim) \
    i_method  (X,Y,   public, string,  mid, num, num) \
    i_method  (X,Y,   public, none,    reserve, num) \
    i_method  (X,Y,   public, none,    writef, handle, bool) \
    i_method  (X,Y,   public, bool,    ends_with, symbol) \
    i_method  (X,Y,   public, bool,    starts_with, symbol) \
    i_method  (X,Y,   public, num,     cmp, symbol) \
    i_method  (X,Y,   public, bool,    eq,  symbol) \
    i_method  (X,Y,   public, string,  interpolate, A) \
    i_cast    (X,Y,   public, cstr) \
    i_cast    (X,Y,   public, sz) \
    i_cast    (X,Y,   public, path) \
    i_ctr     (X,Y,   public, symbol) \
    i_ctr     (X,Y,   public, cstr) \
    i_ctr     (X,Y,   public, i32) \
    i_index   (X,Y,   public, i32, num) \
    i_override(X,Y,   method, hash) \
    i_override(X,Y,   method, compare) \
    i_override(X,Y,   method, init) \
    i_override(X,Y,   cast,   bool) \
    i_override(X,Y,   method, copy)
declare_class(string)

#define command_schema(X,Y,...) \
    i_method  (X,Y, public, i32,    exec) \
    i_method  (X,Y, public, string, run) \
    s_method  (X,Y, public, i64, last_pid)
declare_class_2(command, string)

#define watch_schema(X,Y,...) \
    i_prop      (X,Y, public, path, res) \
    i_prop      (X,Y, public, ARef, callback) \
    i_prop      (X,Y, public, ARef, argument) \
    i_method    (X,Y, public, none, pause) \
    i_method    (X,Y, public, none, start) \
    i_override  (X,Y, method, init)
declare_class(watch)

#define mutex_schema(X,Y,...) \
    i_prop      (X,Y, public, bool, cond) \
    i_method    (X,Y, public, none, lock) \
    i_method    (X,Y, public, none, unlock) \
    i_method    (X,Y, public, none, cond_wait) \
    i_method    (X,Y, public, none, cond_signal) \
    i_method    (X,Y, public, none, cond_broadcast) \
    i_prop      (X,Y, intern, struct mutex_t*, mtx, as, ARef) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, method, dealloc)
declare_class(mutex)

#define async_schema(X,Y,...) \
    i_prop      (X,Y, public, hook,     work_fn) \
    i_prop      (X,Y, public, array,    work) \
    i_prop      (X,Y, intern, mutex,    global) \
    i_prop      (X,Y, intern, struct thread_t*, threads, as, ARef) \
    i_method    (X,Y, public, A,   sync, A) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, method, dealloc)
declare_class(async)
 
#define path_schema(X,Y,...) \
    i_method    (X,Y, public, bool,   exists) \
    i_method    (X,Y, public, bool,   touch) \
    i_method    (X,Y, public, bool,   create_symlink, path) \
    i_method    (X,Y, public, bool,   is_symlink) \
    i_method    (X,Y, public, path,   resolve) \
    i_method    (X,Y, public, bool,   make_dir) \
    i_method    (X,Y, public, bool,   remove_dir) \
    i_method    (X,Y, public, bool,   is_ext, symbol) \
    i_method    (X,Y, public, bool,   is_empty) \
    i_method    (X,Y, public, bool,   is_dir) \
    i_method    (X,Y, public, none,   cp, path, bool, bool) \
    i_method    (X,Y, public, path,   directory) \
    i_method    (X,Y, public, none,   cd) \
    i_method    (X,Y, public, string, stem) \
    i_method    (X,Y, public, string, ext) \
    i_override  (X,Y, method, eq) \
    i_method    (X,Y, public, string, filename) \
    i_method    (X,Y, public, path,   absolute) \
    i_method    (X,Y, public, path,   parent) \
    i_method    (X,Y, public, A,      load, AType, ctx) \
    i_method    (X,Y, public, bool,   save, A,     ctx) \
    i_method    (X,Y, public, path,   change_ext, cstr) \
    i_method    (X,Y, public, array,  ls, string, bool) \
    i_method    (X,Y, public, bool,   move, path) \
    i_method    (X,Y, public, path,   latest_modified, ARef) \
    i_method    (X,Y, public, i64,    modified_time) \
    s_method    (X,Y, public, path,   self) \
    s_method    (X,Y, public, path,   share_path, cstr) \
    s_method    (X,Y, public, path,   cwd) \
    s_method    (X,Y, public, path,   tempfile, symbol) \
    i_ctr       (X,Y, public, string) \
    i_override  (X,Y, ctr,      symbol) \
    i_override  (X,Y, ctr,      cstr) \
    i_override  (X,Y, cast,     cstr) \
    i_override  (X,Y, cast,     sz) \
    i_override  (X,Y, method,   hash) \
    i_override  (X,Y, method,   init) \
    i_override  (X,Y, cast,     bool) \
    i_override  (X,Y, cast,     string)
declare_class_2(path, string)

#define subscriber_schema(X,Y,...) \
    i_prop    (X,Y, required, A,   target) \
    i_prop    (X,Y, required, callback, method)
declare_class(subscriber)

#define subs_schema(X,Y,...) \
    i_prop    (X,Y, public,   array,  entries, meta, subscriber) \
    i_method  (X,Y, public,   none,   add,    A, callback) \
    i_method  (X,Y, public,   A, invoke, A)
declare_class(subs)


#define line_schema(X,Y,...) \
    i_prop(X,Y, public, i32, indent) \
    i_prop(X,Y, public, array, text)
#undef line_intern
#define line_intern(X,Y,...) line_schema(X,Y,__VA_ARGS__)
declare_class(line)

extern FILE* logger;

cstr copy_cstr(cstr input);

/// useful utility for smooth movement of any variable in a variable-step-rate
/// used in Hyper Race physics to make adjustments to cars at frame-rate
static inline f32 filter_n(f32 current, f32 goal, f32 amount, f32 rate) {
    f32 decay = powf(1.0f - amount, rate);
    if (goal != 0.0f)
        return current + ((goal - current) * (1.0f - decay));
    else
        return current * decay;
}

A      A_i8(i8);
A      A_u8(u8);
A      A_i16(i16);
A      A_u16(u16);
A      A_i32(i32);
A      A_u32(u32);
A      A_i64(i64);
A          i(i64);
A      A_sz(sz);
A      A_u64(u64);
A      A_f32(f32);
A      A_f64(f64);
A  float32(f32);
A   real64(f64);
A      A_cstr(cstr);
A      A_none();
A      A_bool(bool);


/// you can be a typedef and a macro -- it makes APIs simpler
shape shape_new(i64 count, ...);
shape shape_from(i64 count, i64* dims);
shape shape_read(FILE* f);


#define array_string_schema(X,Y,...)
declare_class_2(array_string,     array, string)

#define array_map_schema(X,Y,...)
declare_class_2(array_map,        array, map)

static inline f32 f32_mix(f32 a, f32 b, f32 f) {
    return a * (1.0f - f) + b * f;
}

/// use i_struct_ctr_obj for objects or primitives
/// use i_struct_ctr for structs.. this is because we cannot separate * from the token
#define vec_methods(O, Y, T, ...) \
    i_struct_ctr_obj(O,Y, floats) \
    i_struct_method(O, Y, T,    length) \
    i_struct_method(O, Y, O,    add,      O*) \
    i_struct_method(O, Y, O,    sub,      O*) \
    i_struct_method(O, Y, O,    mul,      O*) \
    i_struct_method(O, Y, O,    scale,    f32) \
    i_struct_method(O, Y, T,    dot,      O*) \
    i_struct_method(O, Y, O,    normalize) \
    i_struct_method(O, Y, O,    mix,      O*, f64) \
    i_struct_cast  (O, Y, string)

#define rgb8_schema(O, Y, ...) \
    i_struct_prop(O,Y,u8, r) \
    i_struct_prop(O,Y,u8, g) \
    i_struct_prop(O,Y,u8, b)
declare_struct(rgb8)

#define rgbf_schema(O, Y, ...) \
    i_struct_prop(O,Y, f32, r) \
    i_struct_prop(O,Y, f32, g) \
    i_struct_prop(O,Y, f32, b)
declare_struct(rgbf)

#define rgba8_schema(O, Y, ...) \
    i_struct_prop(O,Y,u8, r) \
    i_struct_prop(O,Y,u8, g) \
    i_struct_prop(O,Y,u8, b) \
    i_struct_prop(O,Y,u8, a)
declare_struct(rgba8)

#define rgba16_schema(O, Y, ...) \
    i_struct_prop(O,Y,u16, r) \
    i_struct_prop(O,Y,u16, g) \
    i_struct_prop(O,Y,u16, b) \
    i_struct_prop(O,Y,u16, a)
declare_struct(rgba16)

typedef struct _vec3f vec3f;

#define vec4f_schema(O, Y, T, ...) \
    i_struct_ctr(O,Y, vec3f) \
    i_struct_prop  (O, Y, T, x) \
    i_struct_prop  (O, Y, T, y) \
    i_struct_prop  (O, Y, T, z) \
    i_struct_prop  (O, Y, T, w) \
    vec_methods(O, Y, T, __VA_ARGS__)
declare_struct(vec4f, f32)

#define rgbaf_schema(O, Y, ...) \
    i_struct_ctr(O,Y, vec4f) \
    i_struct_prop(O,Y, f32, r) \
    i_struct_prop(O,Y, f32, g) \
    i_struct_prop(O,Y, f32, b) \
    i_struct_prop(O,Y, f32, a)
declare_struct(rgbaf)

#define vec3f_schema(O, Y, T, ...) \
    i_struct_prop  (O, Y, T, x) \
    i_struct_prop  (O, Y, T, y) \
    i_struct_prop  (O, Y, T, z) \
    i_struct_method(O, Y, O, cross, O*) \
    i_struct_static(O, Y, O, rand) \
    vec_methods(O, Y, T)
declare_struct(vec3f, f32)

#define quatf_schema(O, Y, ...) \
    i_struct_ctr(O,Y, vec4f) \
    i_struct_prop(O,Y,f32, x) \
    i_struct_prop(O,Y,f32, y) \
    i_struct_prop(O,Y,f32, z) \
    i_struct_prop(O,Y,f32, w)
declare_struct(quatf)

#define rgba_schema(O, Y, ...) \
    i_prop(O,Y, public, f32, r) \
    i_prop(O,Y, public, f32, g) \
    i_prop(O,Y, public, f32, b) \
    i_prop(O,Y, public, f32, a) \
    i_method(O,Y, public, rgba, mix, rgba, f32) \
    i_ctr(O,Y, public, cstr) \
    i_ctr(O,Y, public, string)
declare_class(rgba)

f32 degrees(f32 rads);
f32 radians(f32 degs);

#define vec2f_schema(O, Y, T, ...) \
    i_struct_prop (O, Y, T, x) \
    i_struct_prop (O, Y, T, y) \
    vec_methods   (O, Y, T, __VA_ARGS__)
declare_struct(vec2f, f32)

#define rect_schema(O, Y, ...) \
    i_prop (O, Y, public, f32, x) \
    i_prop (O, Y, public, f32, y) \
    i_prop (O, Y, public, f32, w) \
    i_prop (O, Y, public, f32, h) \
    i_method(O, Y, public, vec2f, xy) \
    s_method(O, Y, public, rect, create_rect, vec2f, vec2f)
declare_class(rect)

#define mat4f_schema(O, Y, T, ...) \
    i_struct_array  (O, Y, f32,   16, m) \
    i_struct_ctr_obj(O, Y, floats) \
    i_struct_ctr    (O, Y, quatf) \
    i_struct_method (O, Y, O,        inverse) \
    i_struct_method (O, Y, O,        transpose) \
    i_struct_static (O, Y, O,        ident) \
    i_struct_static (O, Y, O,        perspective, f32, f32, f32, f32) \
    i_struct_static (O, Y, O,        ortho,      f32, f32, f32, f32, f32, f32) \
    i_struct_static (O, Y, O,        look_at,    vec3f*, vec3f*, vec3f*) \
    i_struct_method (O, Y, O,        scale,      vec3f*) \
    i_struct_method (O, Y, O,        translate,  vec3f*) \
    i_struct_method (O, Y, O,        rotate,     quatf*) \
    i_struct_method (O, Y, vec4f,    mul_v4,     vec4f*) \
    i_struct_method (O, Y, none,     set_identity) \
    i_struct_method (O, Y, O,        mul,        O*) \
    i_struct_cast   (O, Y, string)
declare_struct(mat4f, f32)

// will need to adjust json serialization to facilitate vector with meta types
#define vector_mat4f_schema(X,Y,...)
declare_class_2(vector_mat4f, vector, mat4f)

#define vector_vec4f_schema(X,Y,...)
declare_class_2(vector_vec4f, vector, vec4f)

#define vector_vec3f_schema(X,Y,...)
declare_class_2(vector_vec3f, vector, vec3f)

#define vector_vec2f_schema(X,Y,...)
declare_class_2(vector_vec2f, vector, vec2f)

#define vector_i8_schema(X,Y,...)
declare_class_2(vector_i8, vector, i8)

#define vector_f32_schema(X,Y,...)
declare_class_2(vector_f32, vector, f32)

#define vector_f64_schema(X,Y,...)
declare_class_2(vector_f64, vector, f64)

#define vector_i64_schema(X,Y,...)
declare_class_2(vector_i64, vector, i64)

#define vector_rgba8_schema(X,Y,...)
declare_class_2(vector_rgba8, vector, rgba8)

#define vector_rgba16_schema(X,Y,...)
declare_class_2(vector_rgba16, vector, rgba16)

#define vector_rgbaf_schema(X,Y,...)
declare_class_2(vector_rgbaf, vector, rgbaf)

#define vector_rgb8_schema(X,Y,...)
declare_class_2(vector_rgb8, vector, rgb8)

#define vector_rgbf_schema(X,Y,...)
declare_class_2(vector_rgbf, vector, rgbf)

vector_f32   vector_f32_new  (shape count, ...);
vector_f64   vector_f64_new  (shape count, ...);
vector_i8    vector_i8_new   (shape count, ...);
vector_i64   vector_i64_new  (shape count, ...);
vector_rgba16 vector_rgba16_new(shape count, ...);
vector_rgba8 vector_rgba8_new(shape count, ...);
vector_rgbaf vector_rgbaf_new(shape count, ...);
vector_rgb8  vector_rgb8_new (shape count, ...);
vector_rgbf  vector_rgbf_new (shape count, ...);

#define weak_schema(X,Y,...)
declare_abstract(weak)

#define functional_schema(X,Y,...)
declare_abstract(functional)

#define cast(T,I) fcall(I, cast_##T)

#ifdef __cplusplus
}
#endif

#endif