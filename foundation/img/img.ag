import AcademySoftwareFoundation:Imath/c0396a0 

import AcademySoftwareFoundation:openexr/0b83825
    -DBUILD_SHARED_LIBS=ON

import madler:zlib/51b7f2a <zlib.h>
    -DCMAKE_POLICY_VERSION_MINIMUM=3.5

import glennrp:libpng/07b8803 <png.h>
    -DCMAKE_POLICY_VERSION_MINIMUM=3.5
    -DZLIB_LIBRARY=$IMPORT/lib/libz.so
    -DZLIB_INCLUDE_DIR=$IMPORT/include
    -DCMAKE_C_STANDARD_LIBRARIES="-lm"

import <string.h>


# all 4 opencv functions implemented in img.cc
func opencv_resize_area[ref u8, ref u8, int, int, int, int, int, int] -> none

func opencv_gaussian[ref u8, ref u8, int, int, int, int, float] -> none

func opencv_gaussian_fast[ref u8, ref u8, int, int, int, int , float] -> none

func opencv_blur_equirect[ref u8, int, int] -> none

enum Pixel
    none            : 0
    rgba8           : 1
    rgb8            : 2
    rgbf32          : 3
    u8              : 4
    rgbaf32         : 5
    f32             : 6

enum Filter
    none            : 0
    nearest         : 1
    bilinear        : 3
    trilinear       : 4
    low             : 5
    med             : 6
    high            : 7

enum Surface
    none            : 0
    color           : 1
    normal          : 2
    emission        : 3
    rough           : 4
    metal           : 5
    height          : 6
    ao              : 7
    ior             : 8
    environment     : 9

enum join
    none            : 0
    miter           : 1
    round           : 2
    bevel           : 3

enum cap
    none            : 0
    round           : 1
    square          : 2

enum variant
    none            : 0
    small_caps      : 1
    mono            : 2

class font
    uri         : path
    bold        : bool
    italic      : bool
    underline   : bool
    var         : variant
    size        : f32
    kerning     : f32
    res         : handle
    tf          : handle
    
    intern static font_manager_init    : hook
    intern static font_manager_dealloc : hook

    static func set_font_manager[ init:hook, dealloc:hook ] -> none
        font_manager_init    : init
        font_manager_dealloc : dealloc

    func dealloc[] -> none
        font_manager_dealloc a

    func copy[ ] -> font
        b : super.copy
        font_manager_init b 
        return b

    func init[] -> none
        font_manager_init a

    construct [ u:path ]
        uri = u


class image
    uri:            path
    surface:        Surface
    format:         Pixel
    pixel_size:     i32
    width:          i32
    height:         i32
    channels:       i32
    source:         Au
    filter:         Filter
    user:           Au
    res2:           handle
    res_dealloc:    hook
    res_bits:       ARef

    construct [ i:symbol ]
        uri = path i
    
    construct [ i:cstr ]
        uri = path i
    
    construct [ i:string ]
        uri = path i

    func exr [ path ] -> i32

    func init    [ ] -> none

    func dealloc [ ] -> none # some comment
        info : header[ a ]
        if [ res_dealloc ] res_dealloc [ a ]

    func copy[ ] -> image
        res: image
            :width :height :format :surface
        memcpy res.vdata, vdata, byte_count
        return res

    func resize[ out_w:i32, out_h:i32 ] -> image
        check width > 0 && height > 0, "null image given to resize"
        check out_w > 0 && out_h  > 0, "invalid size"
        
        if [ width == out_w && height == out_h ]
            return copy
        
        scale_x : float width / out_w
        scale_y : float height / out_h

        output  : image
            width    :out_w,
            height   :out_h,
            :format, :surface, :channels

        src : ref u8 vdata
        dst : ref u8 output.vdata

        opencv_resize_area
            src,      dst,   format == Pixel.rgbaf32,
            width,    height,
            channels, out_w, out_h
        
        return output

    func gaussian[ amount:float ] -> image
        if [ amount < 0.1f ]
            return copy
        
        output : image
            :width,  :height,
            :format, :surface, :channels

        src : ref u8 vdata
        dst : ref u8 output.vdata

        opencv_gaussian
            src, dst, format == Pixel.rgbaf32,
            width, height, channels, amount
        
        return output


    # save gray or colored png based on channel count; if we want conversion we may just use methods to alter an object
    func png [ uri:path ] -> i32
        e       : uri.ext
        success : 1

        if [ e == "png" ]
            # lets support libpng only, so only "png" ext from path
            file : fopen [ uri, "wb" ]
            check file, "could not open file for writing: %o", uri

            png2 : png_create_write_struct[ PNG_LIBPNG_VER_STRING, null, null, null ]
            check png2, "could not create PNG write struct"

            info : png_create_info_struct [ png2 ]
            check info, "could not create PNG info struct"

            if [ !setjmp( png_jmpbuf( png2 ) ) ]
                png_init_io png2, file

                #png_t_seIHDR

                png_set_IHDR
                    png2, info, width, height,
                    8, PNG_COLOR_TYPE_RGBA, PNG_INTERLACE_NONE,
                    PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT

                png_write_info png2, info
                rows : new png_bytep [ sizeof png_bytep * height ]
                data : ref u8 vdata

                for [ y : 0, y < height, y++ ]
                    rows[y] = ref data [ y * width * channels ]

                png_write_image png2, rows
                png_write_end   png2, null
            else
                success = 0
            
            png_destroy_write_struct ref png2, ref info
            fclose file

        else
            fault 'unsupported format: {e}'
            success = 0
        
        return success


    func len[ ] -> num
        return height

    func byte_count[ ] -> num
        f : header[ a ]
        return f.count * f.scalar.size

    func get[ y:num ] -> Au
        return ref u8 vdata [ pixel_size * width * y ]
