import AcademySoftwareFoundation:Imath/c0396a0 

import AcademySoftwareFoundation:openexr/0b83825
    -DBUILD_SHARED_LIBS=ON

import madler:zlib/51b7f2a <zlib.h>
    -DCMAKE_POLICY_VERSION_MINIMUM=3.5

import glennrp:libpng/07b8803 <png.h>
    -DCMAKE_POLICY_VERSION_MINIMUM=3.5
    -DZLIB_LIBRARY=$IMPORT/lib/libz.so
    -DZLIB_INCLUDE_DIR=$IMPORT/include
    -DCMAKE_C_STANDARD_LIBRARIES="-lm"

import <string.h>

func set_font_manager [ hook, hook ] -> none

enum Pixel
    none            : 0
    rgba8           : 1
    rgb8            : 2
    rgbf32          : 3
    u8              : 4
    rgbaf32         : 5
    f32             : 6


enum Filter
    none            : 0
    nearest         : 1
    bilinear        : 3
    trilinear       : 4
    low             : 5
    med             : 6
    high            : 7


enum Surface
    none            : 0
    color           : 1
    normal          : 2
    emission        : 3
    rough           : 4
    metal           : 5
    height          : 6
    ao              : 7
    ior             : 8
    environment     : 9


enum join
    none            : 0
    miter           : 1
    round           : 2
    bevel           : 3


enum cap
    none            : 0
    round           : 1
    square          : 2


enum variant
    none            : 0
    small_caps      : 1
    mono            : 2


class font
    uri:path            
    bold:bool            
    italic:bool            
    underline:bool            
    var:variant         
    size:f32             
    kerning:f32             
    res:handle          
    tf:handle          
    
    intern static font_manager_init    : hook
    intern static font_manager_dealloc : hook

    func set_font_manager[ init:hook, dealloc:hook ] -> none
        font_manager_init    : init
        font_manager_dealloc : dealloc

    func dealloc[] -> none
        font_manager_dealloc f

    func copy[ ] -> font
        b : super.copy
        font_manager_init b 
        return b

    func init[] -> none
        font_manager_init a
        return f

    func font_from_path[ uri:path ] -> font
        a.uri = uri
        return f


class image
    uri:            path
    surface:        Surface
    format:         Pixel
    pixel_size:     i32
    width:          i32
    height:         i32
    channels:       i32
    source:         Au
    filter:         Filter
    user:           Au
    res:            handle
    res_dealloc:    hook
    res_bits:       ARef

    construct [ i:symbol ]
        uri = path i
    
    construct [ i:cstr ]
        uri = path i
    
    construct [ string i ]
        uri = path i

    func exr [ path ] -> i32    # implemented in cc

    func init    [ ] -> none    # implemented in cc
    func dealloc [ ] -> none    # implemented in cc
        info : header
        if [ res_dealloc ]
            res_dealloc [ a ]
            info.data = null
        if [ !res_bits ]
            drop info.data
            info.data = null

    func copy[] -> image
        res: image[ :width :height :format :surface ]
        memcpy res.vdata, vdata, byte_count
        return res

    func resize[ out_w:i32, out_h:i32 ] -> image
        check width > 0 && height,    "null image given to resize"
        check out_w > 0 && out_h > 0,  "invalid size"
        
        if [ in_w == out_w && in_h == out_h ]
            return copy
        
        scale_x : float width / out_w
        scale_y : float height / out_h
        output  : image
            width    :out_w,
            height   :out_h,
            :format, :surface, :channels
        
        src : ref u8 vdata
        dst : ref u8 output.vdata

        opencv_resize_area
            src,      dst,   format == Pixel_rgbaf32,
            width,    height,
            channels, out_w, out_h
        
        return output

    func gaussian[ amount:float ] -> image
        if [ amount < 0.1f ]
            return copy
        
        output : image
            :width,  :height,
            :format, :surface, :channels

        src : ref u8 vdata
        dst : ref u8 output.vdata
        opencv_gaussian src, dst, input.format == Pixel_rgbaf32, width, height, channels, amount
        return output


    # save gray or colored png based on channel count; if we want conversion we may just use methods to alter an object
    func png [ uri:path ] -> i32
        e : string ext [ uri ]
        success : 1

        if [ e == "png" ]
            # lets support libpng only, so only "png" ext from path
            file : fopen [ uri, "wb" ]
            check file, "could not open file for writing: %o", uri

            png : png_create_write_struct[ PNG_LIBPNG_VER_STRING, null, null, null ]
            check png, "could not create PNG write struct"

            info : png_create_info_struct [ png ]
            check info, "could not create PNG info struct"

            if [ !setjmp[ png_jmpbuf[ png ]] ]
                png_init_io png, file
                png_t_seIHDR png, info, width, height, 8, # 8-bit per channel
                    (channels == 1) ? PNG_COLOR_TYPE_GRAY :
                    (channels == 3) ? PNG_COLOR_TYPE_RGB  :
                    (channels == 4) ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_GRAY_ALPHA,
                    PNG_INTERLACE_NONE,
                    PNG_COMPRESSION_TYPE_DEFAULT,
                    PNG_FILTER_TYPE_DEFAULT

                png_write_info png, info
                rows : ref png_bytep malloc [ sizeof(png_bytep) * height ]
                data : ref u8 vdata

                for [ y : 0, y < a->height, y++ ]
                    rows[y] = ref data [ y * width * channels ]

                png_write_image png, rows
                png_write_end   png, null
            else
                success = 0
            
            png_destroy_write_struct ref png, ref info
            fclose file

        else
            fault 'unsupported format: {e}'
            success = 0
        
        return success


    func len[ ] -> num
        return a->height

    func byte_count[ ] -> num
        f : head a
        return f.count * f.scalar.size

    func get[ num y ] -> Au
        return ref u8 vdata [ pixel_size * width * y ]
